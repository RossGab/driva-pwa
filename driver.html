<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Driver Tasks</title>

<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#222222">

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f4f4;
  padding: 10px;
}

#appVersion {
  background: #222;
  color: #fff;
  padding: 8px;
  text-align: center;
  margin-bottom: 6px;
}

#offlineBanner {
  background: #c0392b;
  color: #fff;
  padding: 6px;
  text-align: center;
  margin-bottom: 10px;
  display: none;
}

/* üîç SEARCH */
#searchBox {
  width: 100%;
  padding: 10px;
  margin-bottom: 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
  font-size: 14px;
}

.task {
  background: #fff;
  padding: 12px;
  margin-bottom: 10px;
  border-radius: 8px;
  border-left: 5px solid orange;
}

.task.completed {
  border-left-color: green;
}

.small {
  font-size: 13px;
  color: #555;
  margin-top: 4px;
}
.radio-group {
  margin-top: 6px;
  font-size: 14px;
}

.radio-group label {
  display: block;
  margin-top: 4px;
}

textarea {
  width: 100%;
  min-height: 60px;
  margin-top: 6px;
  padding: 6px;
  font-size: 14px;
  resize: vertical;
}

.radio-group input:disabled {
  opacity: 0.6;
}

.radio-group input:disabled + span {
  color: #999;
}

.offline-indicator {
  margin-top: 6px;
  font-weight: bold;
  color: #c0392b;
}

.uploading {
  margin-top: 6px;
  font-weight: bold;
  color: #f39c12;
}

button {
  width: 100%;
  padding: 10px;
  margin-top: 6px;
  border-radius: 6px;
  border: none;
  font-size: 14px;
}

button:disabled {
  background: #aaa;
}

.capture { background: #007bff; color: #fff; }
.toggle { background: #0069d9; color: #fff; }

img {
  width: 100%;
  margin-top: 8px;
  border-radius: 6px;
}
</style>
</head>

<body>

<div id="appVersion"></div>
<div id="offlineBanner">‚ö† Offline ‚Äî photos will upload automatically</div>

<!-- üîç SEARCH INPUT -->
<input id="searchBox" placeholder="Search tasks (name, address, remarks, etc.)">

<div id="taskList">Loading tasks...</div>

<input type="file" id="cameraInput" accept="image/*" capture="environment" hidden>



<script type="module">
  
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getDatabase, ref, get, update, query,
  orderByChild, equalTo
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
import {
  getStorage, ref as sRef, uploadBytes, getDownloadURL
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

const VERSION = "Driver v3.5.0";
  // üîí Billing data cache (per task)
const BILLING_CACHE = {};

/* ================= CONFIG ================= */
const firebaseConfig = {
  apiKey: "AIzaSyDFW61pnwLvh6HGKWt10zLYNr860fI8vkg",
  authDomain: "driva-pwa.firebaseapp.com",
  databaseURL: "https://driva-pwa-default-rtdb.firebaseio.com",
  projectId: "driva-pwa",
  storageBucket: "driva-pwa.firebasestorage.app",
  messagingSenderId: "299138219722",
  appId: "1:299138219722:web:623ff6b0a067ea822dfe33"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const storage = getStorage(app);

/* ================= CONSTANTS ================= */
const QUEUE_KEY = "offlineQueue";
const TASK_CACHE_KEY = "cachedTasks";
const PRIORITY = {
  PENDING: 1,
  PROCESSING: 1.5,
  UPLOADING: 2,
  SAVED: 2,
  COMPLETED: 3
};

const processingMap = {};
const uploadingMap = {};
let SEARCH_TERM = "";
const DRIVER_UI_CACHE = {};

/* ================= DRIVER ================= */
let DRIVER_ID = localStorage.getItem("driverId");
while (!DRIVER_ID) DRIVER_ID = prompt("Enter Driver ID");
localStorage.setItem("driverId", DRIVER_ID);
document.getElementById("appVersion").innerText =
  `Driver: ${DRIVER_ID} | ${VERSION}`;

async function loadDriverUIConfig(jobType) {
  if (DRIVER_UI_CACHE[jobType]) {
    return DRIVER_UI_CACHE[jobType];
  }

  const snap = await get(
    ref(db, `config/driverUI/jobTypes/${jobType}/deliveryMethods`)
  );

  const data = snap.val() || {};
  DRIVER_UI_CACHE[jobType] = data;
  return data;
}


// ================= LIVE DRIVER LOCATION =================
const LOCATION_INTERVAL = 45000; // 45 seconds
let lastLocationSent = 0;

function startLiveTracking() {
  if (!("geolocation" in navigator)) {
    console.warn("Geolocation not supported");
    return;
  }

  navigator.geolocation.watchPosition(
    pos => {
      if (!navigator.onLine) return;

      const now = Date.now();
      if (now - lastLocationSent < LOCATION_INTERVAL) return;
      lastLocationSent = now;

      update(ref(db, `driverStatus/${DRIVER_ID}`), {
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude,
        lastSeen: new Date().toISOString(),
        driverId: DRIVER_ID
      });
    },
    err => console.error("Location error:", err),
    {
      enableHighAccuracy: true,
      maximumAge: 10000,
      timeout: 15000
    }
  );
}
startLiveTracking();


/* ================= SEARCH ================= */
document.getElementById("searchBox").addEventListener("input", e => {
  SEARCH_TERM = e.target.value.toLowerCase();
  loadTasks();
});

/* ================= NETWORK ================= */
function updateNetwork() {
  document.getElementById("offlineBanner").style.display =
    navigator.onLine ? "none" : "block";
}
window.addEventListener("online", updateNetwork);
window.addEventListener("offline", updateNetwork);
updateNetwork();

/* ================= GEO ================= */
function getLocation() {
  return new Promise(resolve => {
    navigator.geolocation.getCurrentPosition(
      pos => resolve(pos.coords),
      () => resolve(null),
      { enableHighAccuracy: true, timeout: 10000 }
    );
  });
}

/* ================= QUEUE ================= */
const getQueue = () =>
  JSON.parse(localStorage.getItem(QUEUE_KEY) || "[]");

const setQueue = q =>
  localStorage.setItem(QUEUE_KEY, JSON.stringify(q));

/* ================= IMAGE ================= */
function compressImage(file) {
  return new Promise(resolve => {
    const img = new Image();
    const reader = new FileReader();
    reader.onload = e => img.src = e.target.result;

    img.onload = () => {
      const canvas = document.createElement("canvas");
      let w = img.width;
      let h = img.height;
      if (w > 1280) { h *= 1280 / w; w = 1280; }
      canvas.width = w;
      canvas.height = h;
      canvas.getContext("2d").drawImage(img, 0, 0, w, h);
      canvas.toBlob(b => resolve(b), "image/jpeg", 0.65);
    };
    reader.readAsDataURL(file);
  });
}

const toBase64 = blob =>
  new Promise(r => {
    const f = new FileReader();
    f.onloadend = () => r(f.result);
    f.readAsDataURL(blob);
  });

function saveToGallery(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/* ================= STATUS ================= */
function resolveStatus(task, offlineItem) {
  const key = task._key;

  if (processingMap[key]) return "PROCESSING";
  if (task.status === "COMPLETED") return "COMPLETED";
  if (uploadingMap[key]) return "UPLOADING";
  if (offlineItem || task.imageUrl) return "SAVED";
  return "PENDING";
}
  
/* ================= CAMERA ================= */
let CURRENT_TASK = null;
const camera = document.getElementById("cameraInput");

window.takePicture = key => {
  CURRENT_TASK = key;

  if (isBillingJob(key) && !await validateDriverFields(key, task.JOBTYPE)) {
  return;
}

  camera.value = "";
  camera.click();
};

camera.addEventListener("change", async e => {
  if (!e.target.files[0] || !CURRENT_TASK) return;

  const textarea = document.getElementById(`remarks_${CURRENT_TASK}`);
  const remarks = textarea ? textarea.value.trim() : "";
  const selected = document.querySelector(`input[name="delivery_${CURRENT_TASK}"]:checked`);

  const deliveryType = selected ? selected.value : null;
  
  if (!deliveryType) {
    alert("Please select delivery method");
    CURRENT_TASK = null;
    return;
  }

 // üîí START PROCESSING (ONLY ONCE)
  processingMap[CURRENT_TASK] = true;
  loadTasks();
  
  // ‚úÖ DEFINE takenAt FIRST (CRITICAL)
  const takenAt = new Date().toISOString();
  
  let coords;
  try {
    coords = await getLocation();
  } catch {
    coords = null;
  }
  
  const cached = JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]");
  const task = cached.find(t => t._key === CURRENT_TASK);
  
  const safe = v => String(v || "").toLowerCase().replace(/[^a-z0-9]/g, "_");
  const filename =
    `${safe(task?.CUSTOMERNAME)}_${safe(task?.ADDRESS)}_${coords?.latitude || "0"}_${coords?.longitude || "0"}_${takenAt.replace(/[:.]/g, "-")}_${DRIVER_ID}.jpg`;
  
  let blob;
  try {
    blob = await compressImage(e.target.files[0]);
    saveToGallery(blob, filename);
  } catch (e) {
    alert("Image processing failed");
    delete processingMap[CURRENT_TASK];
    loadTasks();
    return;
  }
  
  // ‚úÖ PROCESSING DONE ‚Äî ALWAYS CLEAR
  delete processingMap[CURRENT_TASK];
  loadTasks();

// ================= OFFLINE =================
if (!navigator.onLine) {
  const q = getQueue();
  const billing = BILLING_CACHE[CURRENT_TASK] || {};

  q.push({
    taskKey: CURRENT_TASK,
    image: await toBase64(blob),
    takenAt,
    latitude: coords?.latitude,
    longitude: coords?.longitude,
    filename,
    deliveryType: billing.deliveryType || "",
    remarks: billing.remarks || "",
    receivedBy: billing.receivedBy || "",
    relationship: billing.relationship || "",
    gateColor: billing.gateColor || ""
  });

  setQueue(q);

  // üîë DO NOT touch uploadingMap when offline
  loadTasks();
  return;
}

// ================= ONLINE =================
uploadingMap[CURRENT_TASK] = true;
loadTasks();

try {
  const billing = BILLING_CACHE[CURRENT_TASK] || {};

  await uploadNow(
    CURRENT_TASK,
    blob,
    takenAt,
    coords,
    billing.remarks || remarks || "",
    billing.deliveryType || deliveryType || "",
    filename,
    billing.receivedBy || "",
    billing.relationship || "",
    billing.gateColor || ""
  );
} catch {
  alert("Upload failed. Please retake the photo.");
} finally {
  delete uploadingMap[CURRENT_TASK];
  loadTasks();
}
});

/* ================= UPLOAD ================= */
async function uploadNow(
      taskKey,
      blob,
      takenAt,
      coords,
      remarks,
      deliveryType,
      filename,
      receivedBy = "",
      relationship = "",
      gateColor = ""
    ) {
  const uploadedAt = new Date().toISOString();
  const imgRef = sRef(storage, `tasks/${taskKey}/${filename}`);

  await uploadBytes(imgRef, blob);
  const url = await getDownloadURL(imgRef);

  const billing = BILLING_CACHE[taskKey] || {};

  await update(ref(db, `tasks/${taskKey}`), {
    status: "COMPLETED",
    imageUrl: url,
    deliveryType,
    deliveryData: BILLING_CACHE[taskKey], // üî• ALL FIELDS
    takenAt,
    uploadedAt,
    latitude,
    longitude
  });;

  loadTasks();
}

/* ================= OFFLINE SYNC (RESTORED) ================= */
setInterval(async () => {
  if (!navigator.onLine) return;

  const q = getQueue();
  if (!q.length) return;

  for (const i of q) {
    try {
      const blob = await (await fetch(i.image)).blob();

      await uploadNow(
        i.taskKey,
        blob,
        i.takenAt,
        { latitude: i.latitude, longitude: i.longitude },
        i.remarks,
        i.deliveryType,
        i.filename,
        i.receivedBy,
        i.relationship,
        i.gateColor
      );
    } catch (err) {
      console.error("Retry upload failed", err);
      return; // stop loop, retry next interval
    }
  }

  setQueue([]); // clear only after successful uploads
  loadTasks();
}, 5000);

/* ================= LOAD ================= */
async function loadTasks() {
  let tasks = JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]");

  if (navigator.onLine) {
    const snap = await get(
      query(ref(db, "tasks"), orderByChild("driverId"), equalTo(DRIVER_ID))
    );
    const raw = snap.val() || {};
    tasks = Object.keys(raw).map(k => ({ _key: k, ...raw[k] }));
    localStorage.setItem(TASK_CACHE_KEY, JSON.stringify(tasks));
  }

  if (SEARCH_TERM) {
    tasks = tasks.filter(t =>
      JSON.stringify(t).toLowerCase().includes(SEARCH_TERM)
    );
  }

  render(tasks);
}

/* ================= RENDER ================= */
function render(tasks) {
  const list = document.getElementById("taskList");
  list.innerHTML = "";

  const offlineMap = Object.fromEntries(
    getQueue().map(i => [i.taskKey, i])
  );

  tasks.sort((a, b) => {
    const sa = resolveStatus(a, offlineMap[a._key]);
    const sb = resolveStatus(b, offlineMap[b._key]);
    return PRIORITY[sa] - PRIORITY[sb];
  });

  tasks.forEach(t => {
    const q = offlineMap[t._key];
    const status = resolveStatus(t, q);
    const isBilling = (t.JOBTYPE || "").toUpperCase().includes("BILLING");

    const div = document.createElement("div");
    div.className = `task ${status === "COMPLETED" ? "completed" : ""}`;

    div.innerHTML = `
  <b>${t.CUSTOMERNAME || "‚Äî"}</b>

  <div class="small">
    üìç ${t.ADDRESS || "‚Äî"}
  </div>

  <div class="small">
    <b>Account #:</b> ${t.ACCOUNTNUMBER || "‚Äî"}
  </div>

  <div class="small">
    <b>MRU:</b> ${t.MRU || "‚Äî"}
  </div>

  <div class="small">
    <b>Meter #:</b> ${t.METERNUMBER || "‚Äî"}
  </div>

  <div class="small">
    <b>DMZ:</b> ${t.DMZ || "‚Äî"}
  </div>

  <div class="small">
    <b>Sequence:</b> ${t.SEQUENCE || "‚Äî"}
  </div>

  <div class="small">
    <b>Job Type:</b> ${t.JOBTYPE || "‚Äî"}
  </div>

  <div class="small">
    <b>Status:</b> ${status}
  </div>


  ${
    status === "PENDING"
      ? `
        ${isBilling ? renderBillingDelivery(t) : ""}
  
        ${!isBilling ? `
          <textarea id="remarks_${t._key}" placeholder="Remarks (optional)"></textarea>
        ` : ""}
  
        <button class="capture" onclick="takePicture('${t._key}')">
          üì∏ Take Picture
        </button>
      `
      : status === "PROCESSING"
      ? `
        <div class="uploading">üõ† Preparing photo‚Ä¶</div>
      `
      : status === "UPLOADING"
      ? `
        <div class="uploading">‚è≥ Uploading photo‚Ä¶</div>
      `
      : status === "SAVED"
      ? `
        <div class="offline-indicator">üïí Saved offline ‚Äî upload pending</div>
      `
      : status === "COMPLETED"
      ? `
        ${t.remarks ? `<div class="small">üìù ${t.remarks}</div>` : ""}
  
        <button class="toggle"
          onclick="this.nextElementSibling.style.display =
          this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
          üëÅ Show / Hide Photo
        </button>
        <img src="${t.imageUrl}" style="display:none">
      `
      : ""
  }
`;
    list.appendChild(div);
  });
}

async function renderDeliveryMethods(task) {
  const methods = await loadDriverUIConfig(task.JOBTYPE);
  if (!methods || !Object.keys(methods).length) return "";

  return `
    <div class="radio-group">
      <b>Delivery Method</b>

      ${Object.keys(methods).map(m => `
        <label>
          <input type="radio"
            name="delivery_${task._key}"
            value="${m}"
            onchange="showDriverFields('${task._key}', '${task.JOBTYPE}', '${m}')">
          ${m}
        </label>
      `).join("")}
    </div>

    <div id="driver_fields_${task._key}"></div>
  `;
}
  
function billingOption(t, value) {
  const disabled = t.status === "COMPLETED" ? "disabled" : "";

  return `
    <label>
      <input type="radio"
        name="delivery_${t._key}"
        value="${value}"
        ${disabled}
        onchange="showBillingFields('${t._key}', '${value}')">
      ${value}
    </label>
  `;
}

  window.showDriverFields = async function (taskKey, jobType, method) {
  if (!BILLING_CACHE[taskKey]) BILLING_CACHE[taskKey] = {};

  BILLING_CACHE[taskKey].deliveryType = method;

  const methods = await loadDriverUIConfig(jobType);
  const fields = methods[method];
  const box = document.getElementById(`driver_fields_${taskKey}`);
  if (!box) return;

  let html = "";

  Object.entries(fields).forEach(([key, f]) => {
    html += `
      <div class="field">
        <label>
          ${f.label} ${f.required ? "*" : ""}
        </label>

        ${
          f.type === "textarea"
            ? `<textarea oninput="BILLING_CACHE['${taskKey}']['${key}']=this.value"></textarea>`
            : `<input oninput="BILLING_CACHE['${taskKey}']['${key}']=this.value">`
        }
      </div>
    `;
  });

  box.innerHTML = html;
};
  
  window.showBillingFields = function (taskKey, value) {
    if (!BILLING_CACHE[taskKey]) {
      BILLING_CACHE[taskKey] = {};
    }
  
    BILLING_CACHE[taskKey].deliveryType = value;
  
    const box = document.getElementById(`billing_extra_${taskKey}`);
    if (!box) return;
  
    let html = "";
  
    if (value === "D1-Received") {
      html = `
        <input
          placeholder="Received by *"
          oninput="BILLING_CACHE['${taskKey}'].receivedBy = this.value"
        >
        <input
          placeholder="Relationship to owner *"
          oninput="BILLING_CACHE['${taskKey}'].relationship = this.value"
        >
        <textarea
          placeholder="Other remarks"
          oninput="BILLING_CACHE['${taskKey}'].remarks = this.value"
        ></textarea>
      `;
    }
  
    else if (value === "D2-Put in Mailbox" || value === "D3-Inserted in Gate") {
      html = `
        <input
          placeholder="Gate / Mailbox Color *"
          oninput="BILLING_CACHE['${taskKey}'].gateColor = this.value"
        >
        <textarea
          placeholder="Other remarks"
          oninput="BILLING_CACHE['${taskKey}'].remarks = this.value"
        ></textarea>
      `;
    }
  
    else {
      html = `
        <textarea
          placeholder="Other remarks"
          oninput="BILLING_CACHE['${taskKey}'].remarks = this.value"
        ></textarea>
      `;
    }
  
    box.innerHTML = html;

};

function isBillingJob(taskKey) {
  const cached = JSON.parse(localStorage.getItem("cachedTasks") || "[]");
  const t = cached.find(x => x._key === taskKey);
  return (t?.JOBTYPE || "").toUpperCase().includes("BILLING");
}

async function validateDriverFields(taskKey, jobType) {
  const cache = BILLING_CACHE[taskKey] || {};
  const methods = await loadDriverUIConfig(jobType);
  const fields = methods[cache.deliveryType] || {};

  for (const [key, f] of Object.entries(fields)) {
    if (f.required && !cache[key]) {
      alert(`${f.label} is required`);
      return false;
    }
  }
  return true;
}
  
loadTasks();
</script>



<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js");
}
</script>

</body>
</html>
