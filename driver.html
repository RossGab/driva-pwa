
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Driver Tasks</title>

<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#222222">

<style>
body { font-family: Arial, sans-serif; background:#f4f4f4; padding:10px; }
#appVersion { background:#222;color:#fff;padding:8px;text-align:center;margin-bottom:6px; }
#offlineBanner { background:#c0392b;color:#fff;padding:6px;text-align:center;margin-bottom:10px;display:none; }
#searchBox { width:100%;padding:10px;margin-bottom:10px;border-radius:6px;border:1px solid #ccc;font-size:14px; }
.task { background:#fff;padding:12px;margin-bottom:10px;border-radius:8px;border-left:5px solid orange; }
.task.completed { border-left-color:green; }
.small { font-size:13px;color:#555;margin-top:4px; }
.radio-group label { display:block;margin-top:4px; }
textarea { width:100%;min-height:60px;margin-top:6px;padding:6px;font-size:14px; }
.offline-indicator { font-weight:bold;color:#c0392b;margin-top:6px; }
.uploading { font-weight:bold;color:#f39c12;margin-top:6px; }
button { width:100%;padding:10px;margin-top:6px;border-radius:6px;border:none;font-size:14px; }
.capture { background:#007bff;color:#fff; }
.capture-label {
  display: block;
  text-align: center;
  background: #007bff;
  color: #fff;
  padding: 12px;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  user-select: none;
}
#jobTypeOptions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
}

.job-type-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  background: #fff;
  border: 1px solid #ddd;
  padding: 6px 10px;
  border-radius: 18px;
  font-size: 13px;
  cursor: pointer;
  user-select: none;
}

.job-type-chip input {
  margin: 0;
}
.uploading,
.offline-indicator {
  pointer-events: none;
}
.task {
  pointer-events: auto;
}
button.capture {
  position: relative;
  z-index: 9999;
  pointer-events: auto;
}
.toggle { background:#0069d9;color:#fff; }
.delivery-fields {
  display: grid;
  grid-template-columns: 1fr;
  gap: 12px;
  margin-top: 10px;
}

.delivery-fields label {
  font-weight: bold;
  font-size: 13px;
}

.delivery-fields input,
.delivery-fields textarea {
  width: 100%;
  padding: 8px;
  font-size: 14px;
  box-sizing: border-box;
}

.delivery-fields textarea {
  min-height: 90px;
  resize: vertical;
}
img { width:100%;margin-top:8px;border-radius:6px; }
</style>
</head>

<body>
<button id="settingsBtn"
  style="
    position: fixed;
    top: 10px;
    right: 10px;
    width: 42px;
    height: 42px;
    border-radius: 50%;
    border: none;
    background: #fff;
    font-size: 20px;
    box-shadow: 0 2px 6px rgba(0,0,0,.2);
    z-index: 99999;
  ">
  ‚öôÔ∏è
</button>

<div id="appVersion"></div>
<div id="gpsStatus"
  style="background:#fff;padding:6px;text-align:center;
         margin-bottom:6px;border-radius:6px;font-size:13px;">
  üì° Acquiring GPS‚Ä¶
</div>
<div id="taskCounter"
   style="background:#fff;padding:8px;text-align:center;
        margin-bottom:10px;border-radius:6px;font-weight:bold;">
</div>
<button
  id="refreshTasksBtn"
  style="
    width:100%;
    padding:10px;
    margin-bottom:10px;
    border-radius:6px;
    border:none;
    font-size:14px;
    font-weight:bold;
    background:#3498db;
    color:#fff;
  "
>
  üîÑ Download / Refresh Tasks
</button>
<button id="syncBtn"
  style="
    width:100%;
    padding:10px;
    margin-bottom:10px;
    border-radius:6px;
    border:none;
    font-size:14px;
    font-weight:bold;
    background:#2ecc71;
    color:#fff;
  ">
  üîÑ Sync Completed Tasks
</button>
<div id="offlineBanner">‚ö† Offline ‚Äî photos will upload automatically</div>
  <div id="storageBanner"
  style="
    background:#f39c12;
    color:#000;
    padding:8px;
    text-align:center;
    margin-bottom:10px;
    border-radius:6px;
    font-size:13px;
    display:none;
    font-weight:bold;
  ">
  ‚ö† Low storage ‚Äî please free up space to avoid upload issues
</div>
<div id="uploadCounter"
  style="background:#fff;padding:8px;text-align:center;
         margin-bottom:10px;border-radius:6px;
         font-weight:bold;color:#f39c12;">
</div>
<div
  id="uploadNote"
  style="
    display:none;
    background:#fff3cd;
    color:#856404;
    padding:10px;
    margin-bottom:10px;
    border-radius:6px;
    font-size:13px;
    text-align:center;
  "
>
  ‚ÑπÔ∏è <b>Upload in progress</b><br>
  The screen may refresh while uploading.<br>
  <b>Please wait until the upload is completed.</b>
</div>
<button
  id="retryUploadBtn"
  style="
    display:none;
    width:100%;
    padding:10px;
    margin-bottom:10px;
    border-radius:6px;
    border:none;
    font-size:14px;
    font-weight:bold;
    background:#e67e22;
    color:#fff;
  "
  onclick="manualRetryUploads()"
>
  üîÅ Retry Pending Uploads
</button>

<input
  type="date"
  id="dateFilter"
  style="
    width:100%;
    padding:10px;
    margin-bottom:8px;
    border-radius:6px;
    border:1px solid #ccc;
    font-size:14px;
  "
>
<div id="jobTypeFilter"
  style="
    background:#fff;
    padding:10px;
    margin-bottom:8px;
    border-radius:6px;
    font-size:13px;
  ">
  <b>Job Type</b>
  <div id="jobTypeOptions"></div>
</div>
<input id="searchBox" placeholder="Search tasks">
<div id="fatalErrorBox"
  style="
    display:none;
    background:#b00020;
    color:#fff;
    padding:10px;
    margin-bottom:10px;
    border-radius:6px;
    font-size:13px;
    white-space:pre-wrap;
  ">
</div>
<div id="taskList">
  Loading tasks‚Ä¶
  <div id="scrollSentinel"></div>
</div>
<input type="file" id="cameraInput" accept="image/*" capture="environment" hidden>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getDatabase, ref, get, update, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";
import { increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
  
const VERSION = "v4.0.6-WIP";
const BILLING_CACHE = {};
const DRIVER_UI_CACHE = {};
const DRIVER_UI_STORAGE_KEY = "driverUIConfigCache";
const selectedJobTypes = new Set();
const PHOTO_BUFFER = {};
const submitLock = {};
const FORM_CACHE_KEY = "driverFormCache";
let ACTIVE_CAPTURE_TASK = null;
let jobTypeFilterInitialized = false;
let LAST_KNOWN_GPS = null;
let LOAD_IN_PROGRESS = false;
let RENDER_OFFSET = 0;
const PAGE_SIZE = 10;   // Instagram-like chunk
let CURRENT_RENDER_LIST = [];
let IS_DOWNLOADING = false;
let LAST_RENDER_SIGNATURE = "";




const firebaseConfig = {
  apiKey: "AIzaSyDFW61pnwLvh6HGKWt10zLYNr860fI8vkg",
  authDomain: "driva-pwa.firebaseapp.com",
  databaseURL: "https://driva-pwa-default-rtdb.firebaseio.com",
  projectId: "driva-pwa",
  storageBucket: "driva-pwa.firebasestorage.app", // ‚úÖ FIX
  messagingSenderId: "299138219722",
  appId: "1:299138219722:web:623ff6b0a067ea822dfe33"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const storage = getStorage(app);

const DB_NAME = "driver_uploads";
const DB_VERSION = 4; // ‚¨ÖÔ∏è bump version ONCE
const STORE = "photos";
const TASK_STORE = "tasks";
let FORCE_REDOWNLOAD = false;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onupgradeneeded = e => {
      const db = e.target.result;

      // existing store (photos)
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: "id" });
      }

      // task cache store
      if (!db.objectStoreNames.contains(TASK_STORE)) {
        db.createObjectStore(TASK_STORE, { keyPath: "_key" });
      }
    };

    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function savePhotoToDB(record) {
  const db = await openDB();
  const tx = db.transaction(STORE, "readwrite");
  tx.objectStore(STORE).put(record);
}

async function getAllPhotosFromDB() {
  const db = await openDB();
  return new Promise(resolve => {
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
  });
}

async function saveTasksToIndexedDB(tasks) {
  const db = await openDB();
  const tx = db.transaction(TASK_STORE, "readwrite");
  const store = tx.objectStore(TASK_STORE);

  for (const t of tasks) {
    if (!t._key) continue;
  
    if (!t.dateKey) continue; // üî• GUARANTEE dateKey exists
  
    const existing = await new Promise(resolve => {
      const r = store.get(t._key);
      r.onsuccess = () => resolve(r.result || {});
      r.onerror = () => resolve({});
    });
  
    store.put({
      ...existing,
      ...t,
      dateKey: t.dateKey // üî• FORCE overwrite
    });
  }
}

async function getTasksFromIndexedDB() {
  const db = await openDB();
  return new Promise(resolve => {
    const tx = db.transaction("tasks", "readonly");
    const req = tx.objectStore("tasks").getAll();
    req.onsuccess = () => resolve(req.result || []);
  });
}

async function getWithRetry(dbRef, retries = 1, delay = 400) {
  try {
    const snap = await get(dbRef);
    if (snap.exists() || retries === 0) return snap;
  } catch {}

  await new Promise(r => setTimeout(r, delay));
  return getWithRetry(dbRef, retries - 1, delay);
}

async function deletePhotoFromDB(id) {
  const db = await openDB();
  const tx = db.transaction(STORE, "readwrite");
  tx.objectStore(STORE).delete(id);
}

async function deleteTaskFromIndexedDB(taskKey) {
  const db = await openDB();
  const tx = db.transaction("tasks", "readwrite");
  tx.objectStore("tasks").delete(taskKey);
}

function hasCachedTasksForDate(tasks, selectedDate) {
  const dateKey = selectedDate.replace(/-/g, "");

  return tasks.some(t =>
    t.dateKey === dateKey &&
    String(t.driverId || "").trim().toUpperCase() ===
    String(DRIVER_ID).trim().toUpperCase()
  );
}
  
let SEARCH_TERM = "";
let searchTimer
let TASKS_CACHE = [];
const dateFilter = document.getElementById("dateFilter");

const STORAGE_WARNING_THRESHOLD_MB = 300; // warn below 300 MB

async function checkStorageQuota() {
  // Storage API not supported ‚Üí silently ignore
  if (!navigator.storage || !navigator.storage.estimate) return;

  try {
    const { quota, usage } = await navigator.storage.estimate();
    if (!quota || !usage) return;

    const freeMB = (quota - usage) / (1024 * 1024);
    const banner = document.getElementById("storageBanner");

    if (!banner) return;

    if (freeMB < STORAGE_WARNING_THRESHOLD_MB) {
      banner.style.display = "block";
      banner.innerText =
        `‚ö† Low storage (${Math.round(freeMB)} MB left) ‚Äî please free space to avoid upload issues`;
    } else {
      banner.style.display = "none";
    }
  } catch (e) {
    console.warn("Storage check failed", e);
  }
}



// ‚úÖ Default to today
function getTodayPH() {
  return new Date().toLocaleDateString("en-CA", {
    timeZone: "Asia/Manila"
  });
}

dateFilter.value = getTodayPH();

dateFilter.addEventListener("change", () => {
  selectedJobTypes.clear();
  jobTypeFilterInitialized = false;

  loadTasks();
});

function normalizeDatePH(dateStr) {
  if (!dateStr || typeof dateStr !== "string") return null;

  const d = new Date(dateStr);
  if (isNaN(d.getTime())) return null;

  return d.toLocaleDateString("en-CA", {
    timeZone: "Asia/Manila"
  });
}

function refreshUI() {
  applyFiltersOnly();
}

function applyFiltersOnly() {
  const selectedDate = dateFilter.value;
  if (!selectedDate) return;

  const dateKey = selectedDate.replace(/-/g, "");

  let tasks = TASKS_CACHE.filter(t => {
    if (!t || !t._key) return false;

    // correct driver
    if (
      String(t.driverId || "").trim().toUpperCase() !==
      String(DRIVER_ID).trim().toUpperCase()
    ) return false;

    // correct date
    if (t.dateKey !== dateKey) return false;

    // hide completed
    if (resolveStatus(t) === "COMPLETED") return false;

    return true;
  });

  // job type filter
  if (jobTypeFilterInitialized && selectedJobTypes.size > 0) {
    tasks = tasks.filter(t => selectedJobTypes.has(t.JOBTYPE));
  }

  // search
  tasks = tasks.filter(t => matchesSearch(t, SEARCH_TERM));

  tasks = sortTasksOfflineSafe(tasks);

  renderWithPagination(tasks);
  updateRemainingCounter(tasks);
  updateUploadCounter(tasks);
}

function isBusy() {
  return (
    OFFLINE_REPLAY_RUNNING ||
    Object.keys(processingMap).length > 0 ||
    Object.keys(uploadingMap).length > 0
  );
}

const searchBox = document.getElementById("searchBox");

searchBox.addEventListener("input", e => {
  SEARCH_TERM = e.target.value.toLowerCase();

  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    applyFiltersOnly();
  }, 120);
});

let DRIVER_ID = localStorage.getItem("driverId");
while (!DRIVER_ID) DRIVER_ID = prompt("Enter Driver ID");
localStorage.setItem("driverId", DRIVER_ID);

document.getElementById("settingsBtn").onclick = () => {
  const current = localStorage.getItem("driverId") || "";

  const next = prompt("Enter new Driver ID", current);
  if (!next) return;
  if (next === current) return;

  localStorage.setItem("driverId", next);
  alert("Driver ID changed. Reloading‚Ä¶");
  location.reload();
};

let gpsWatchId = null;

appVersion.innerText = `Driver: ${DRIVER_ID} | ${VERSION}`;
startGPSTracking(DRIVER_ID);

async function loadDriverUI(jobType) {
  // 1Ô∏è‚É£ Memory cache
  if (DRIVER_UI_CACHE[jobType]) {
    return DRIVER_UI_CACHE[jobType];
  }

  // 2Ô∏è‚É£ LocalStorage cache
  const stored = JSON.parse(
    localStorage.getItem(DRIVER_UI_STORAGE_KEY) || "{}"
  );

  const cached = stored[jobType];

  // 3Ô∏è‚É£ If offline ‚Üí use cache if available
  if (!navigator.onLine) {
    if (cached) {
      DRIVER_UI_CACHE[jobType] = cached.deliveryMethods || cached;
      return DRIVER_UI_CACHE[jobType];
    }
    return {};
  }

  // 4Ô∏è‚É£ Fetch metadata (updatedAt) FIRST
  const metaSnap = await get(
    ref(db, `config/driverUI/jobTypes/${jobType}/updatedAt`)
  );

  const serverUpdatedAt = metaSnap.val();

  // 5Ô∏è‚É£ Cache HIT + same version ‚Üí reuse
  if (
    cached &&
    cached.updatedAt &&
    serverUpdatedAt &&
    cached.updatedAt === serverUpdatedAt
  ) {
    DRIVER_UI_CACHE[jobType] = cached.deliveryMethods;
    return DRIVER_UI_CACHE[jobType];
  }

  // 6Ô∏è‚É£ Fetch FULL config (changed or first load)
  const snap = await get(
    ref(db, `config/driverUI/jobTypes/${jobType}/deliveryMethods`)
  );

  const deliveryMethods = snap.val() || {};

  // 7Ô∏è‚É£ Save fresh cache
  const payload = {
    updatedAt: serverUpdatedAt || new Date().toISOString(),
    deliveryMethods
  };

  DRIVER_UI_CACHE[jobType] = deliveryMethods;
  stored[jobType] = payload;

  localStorage.setItem(
    DRIVER_UI_STORAGE_KEY,
    JSON.stringify(stored)
  );

  return deliveryMethods;
}

// async function loadDriverUI(jobType) {
//   // 1Ô∏è‚É£ Memory cache
//   if (DRIVER_UI_CACHE[jobType]) return DRIVER_UI_CACHE[jobType];

//   // 2Ô∏è‚É£ LocalStorage cache (OFFLINE SAFE)
//   const stored = JSON.parse(
//     localStorage.getItem(DRIVER_UI_STORAGE_KEY) || "{}"
//   );

//   if (stored[jobType]) {
//     DRIVER_UI_CACHE[jobType] = stored[jobType];
//     return stored[jobType];
//   }

//   // 3Ô∏è‚É£ Online fetch ONLY if online
//   if (!navigator.onLine) {
//     return {}; // offline + no cache = empty
//   }

//   const snap = await get(
//     ref(db, `config/driverUI/jobTypes/${jobType}/deliveryMethods`)
//   );

//   const data = snap.val() || {};

//   // 4Ô∏è‚É£ Save to memory + localStorage
//   DRIVER_UI_CACHE[jobType] = data;
//   stored[jobType] = data;

//   localStorage.setItem(
//     DRIVER_UI_STORAGE_KEY,
//     JSON.stringify(stored)
//   );

//   return data;
// }
document.getElementById("syncBtn").onclick = async () => {
  if (!navigator.onLine) {
    alert("üì¥ Connect to internet first.");
    return;
  }

  const tasks = await getTasksFromIndexedDB();

  const completed = tasks.filter(t =>
    t.status === "LOCAL_COMPLETED" &&
    t.driverId === DRIVER_ID
  );

  if (!completed.length) {
    alert("No completed tasks to sync.");
    return;
  }

  if (!confirm(`Upload ${completed.length} completed tasks?`)) return;

  for (const task of completed) {
    const photos = await getAllPhotosFromDB();
    const related = photos.filter(p => p.taskKey === task._key);

    for (let i = 0; i < related.length; i++) {
      const p = related[i];

      await uploadNow(
        p.taskKey,
        p.blob,
        p.takenAt,
        null,
        p.deliveryData || {},
        p.gps,
        p.photoIndex,
        i === related.length - 1
      );

      await deletePhotoFromDB(p.id);
    }

    await deleteTaskFromIndexedDB(task._key);
  }

  alert("‚úÖ Sync complete.");
  loadTasks();
};

function disablePullToRefresh() {
  document.body.style.overscrollBehaviorY = "contain";
}

function enablePullToRefresh() {
  document.body.style.overscrollBehaviorY = "";
}
  
function toggleJobTypeFilter(show) {
  const box = document.getElementById("jobTypeFilter");
  if (!box) return;

  box.style.display = show ? "block" : "none";
}
  function renderJobTypeFilters(tasks) {
  const container = document.getElementById("jobTypeOptions");
  if (!container) return;

  const selectedDate = dateFilter.value;
  const dateKey = selectedDate.replace(/-/g, "");

  // üî• STRICT DATE + PENDING FILTER
  const safeTasks = tasks.filter(t =>
    t.dateKey === dateKey &&
    resolveStatus(t) === "PENDING"
  );

  // ‚úÖ BUILD COUNTS HERE (THIS WAS MISSING)
  const jobTypeCounts = {};
  for (const t of safeTasks) {
    if (!t.JOBTYPE) continue;
    jobTypeCounts[t.JOBTYPE] =
      (jobTypeCounts[t.JOBTYPE] || 0) + 1;
  }

  const jobTypes = Object.keys(jobTypeCounts).sort();

  container.innerHTML = "";

  // ‚úÖ If no job types ‚Üí hide filter completely
  if (!jobTypes.length) {
    selectedJobTypes.clear();   // ‚úÖ ADD THIS
    toggleJobTypeFilter(false);
    jobTypeFilterInitialized = false;
    return;
  }

  toggleJobTypeFilter(true);

  jobTypes.forEach(type => {
    const label = document.createElement("label");
    label.className = "job-type-chip";

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";

    if (!jobTypeFilterInitialized) {
      checkbox.checked = true;
      selectedJobTypes.add(type);
    } else {
      checkbox.checked = selectedJobTypes.has(type);
    }

    checkbox.onchange = () => {
      if (checkbox.checked) {
        selectedJobTypes.add(type);
      } else {
        selectedJobTypes.delete(type);
      }
      applyFiltersOnly();
    };

    label.appendChild(checkbox);
    label.append(` ${type} (${jobTypeCounts[type]})`);

    container.appendChild(label);
  });

  jobTypeFilterInitialized = true;
}

async function pruneOldTasks() {
  const db = await openDB();
  const tx = db.transaction(TASK_STORE, "readwrite");
  const store = tx.objectStore(TASK_STORE);

  const req = store.getAll();

  req.onsuccess = () => {
    const tasks = req.result || [];

    const now = new Date();
    const nowPH = new Date(
      now.toLocaleString("en-US", { timeZone: "Asia/Manila" })
    );

    tasks.forEach(t => {
      const status = resolveStatus(t);

      // üî• 1Ô∏è‚É£ DELETE if no dateKey
      if (!t.dateKey) {
        store.delete(t._key);
        return;
      }

      // üî• 2Ô∏è‚É£ DELETE pending older than 2 days
      if (status === "PENDING") {
        const created = new Date(t.createdAt || 0);
        const createdPH = new Date(
          created.toLocaleString("en-US", { timeZone: "Asia/Manila" })
        );

        const diffDays =
          (nowPH - createdPH) / (1000 * 60 * 60 * 24);

        if (diffDays >= 2) {
          store.delete(t._key);
        }
      }
    });
  };
}

function syncDynamicFields(taskKey) {
  const box = document.getElementById(`dyn_${taskKey}`);
  if (!box) return;

  if (!BILLING_CACHE[taskKey]) return;

  const inputs = box.querySelectorAll("input, textarea");

  const allowedKeys = new Set();

  // Only allow CURRENT visible inputs
  inputs.forEach(el => {
    const k = el.getAttribute("data-key");
    if (k) allowedKeys.add(k);
  });

  // Purge stale keys
  for (const k of Object.keys(BILLING_CACHE[taskKey])) {
    if (k !== "deliveryType" && k !== "deliverytype_2nd" && !allowedKeys.has(k)) {
      delete BILLING_CACHE[taskKey][k];
    }
  }

  // Sync only current fields
  inputs.forEach(el => {
    const fieldKey = el.getAttribute("data-key");
    if (!fieldKey) return;

    BILLING_CACHE[taskKey][fieldKey] = el.value.trim();
  });
  // ‚úÖ PERSIST FORM STATE
  const all = loadFormCache();
  all[taskKey] = BILLING_CACHE[taskKey];
  saveFormCache(all);
}

function loadFormCache() {
  return JSON.parse(localStorage.getItem(FORM_CACHE_KEY) || "{}");
}

function saveFormCache(cache) {
  localStorage.setItem(FORM_CACHE_KEY, JSON.stringify(cache));
}

function startGPSTracking(driverId) {
  detectGPSPermission();
  if (!navigator.geolocation) return;

  const gpsStatus = document.getElementById("gpsStatus");

  if (gpsWatchId !== null) {
    navigator.geolocation.clearWatch(gpsWatchId);
    gpsWatchId = null;
  }

  gpsWatchId = navigator.geolocation.watchPosition(
    pos => {
      LAST_KNOWN_GPS = {
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude,
        accuracy: pos.coords.accuracy,
        timestamp: Date.now()
      };

      // ‚úÖ UPDATE UI HERE
      if (gpsStatus) {
        gpsStatus.innerText =
          `üì° GPS locked (¬±${Math.round(pos.coords.accuracy)}m)`;
      }

      update(ref(db, `driverStatus/${driverId}`), {
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude,
        accuracy: pos.coords.accuracy || null,
        lastSeen: new Date().toISOString()
      });
    },
    handleGPSError,
    {
      enableHighAccuracy: true,
      maximumAge: 5000,
      timeout: 20000
    }
  );
}

/* ===== NETWORK ===== */
function updateNetwork() {
  offlineBanner.style.display = navigator.onLine ? "none" : "block";
}
window.addEventListener("offline", updateNetwork);
updateNetwork();


/* ===== IMAGE ===== */
function compressImage(file, gps, takenAt) {
  return new Promise(resolve => {
    const img = new Image();
    const r = new FileReader();

    r.onload = e => (img.src = e.target.result);

    img.onload = () => {
      const canvas = document.createElement("canvas");
      let w = img.width;
      let h = img.height;

      // ‚úÖ Resize (recommended values)
      if (w > 1024) {
        h *= 1024 / w;
        w = 1024;
      }

      canvas.width = w;
      canvas.height = h;

      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, w, h);

      // =========================
      // üñäÔ∏è WATERMARK OVERLAY
      // =========================
      if (gps?.latitude && gps?.longitude) {
        const lat = gps.latitude.toFixed(6);
        const lng = gps.longitude.toFixed(6);

        const timeStr = new Date(takenAt).toLocaleString("en-GB", {
          timeZone: "Asia/Manila",
          hour12: false
        });

        const padding = 12;
        const fontSize = Math.max(12, Math.round(w / 45));

        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textBaseline = "bottom";

        const text1 = `üìç ${lat}, ${lng}`;
        const text2 = `üïí ${timeStr} PH`;

        const textWidth = Math.max(
          ctx.measureText(text1).width,
          ctx.measureText(text2).width
        );

        const boxHeight = fontSize * 2 + padding * 1.5;
        const boxWidth = textWidth + padding * 2;

        const x = padding;
        const y = h - padding;

        // Background (semi-transparent black)
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(
          x - padding / 2,
          y - boxHeight,
          boxWidth,
          boxHeight
        );

        // Text
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text1, x, y - fontSize - 4);
        ctx.fillText(text2, x, y);
      }

      // =========================
      // üóúÔ∏è FINAL COMPRESSION
      // =========================
      canvas.toBlob(
        blob => resolve(blob),
        "image/jpeg",
        0.45 // ‚úÖ recommended quality
      );
    };

    r.readAsDataURL(file);
  });
}

  let CURRENT_TASK = null;
let CURRENT_PHOTO_INDEX = null;
let BOOT_WATCHDOG_FIRED = false;

window.startPhoto = async function(index, taskKey) {
  if (!(await validateDynamic(taskKey))) return;

  CURRENT_TASK = taskKey;
  CURRENT_PHOTO_INDEX = index;

  cameraInput.value = "";
  cameraInput.click();
};

cameraInput.onchange = async e => {
  try {
    const file = e.target.files?.[0];   // ‚úÖ ADD THIS LINE

    const taskKey = CURRENT_TASK;
    const photoIndex = CURRENT_PHOTO_INDEX;
  
  CURRENT_TASK = null;
  CURRENT_PHOTO_INDEX = null;
  
  if (!file || !taskKey || !photoIndex) return;
  
  if (!PHOTO_BUFFER[taskKey]) PHOTO_BUFFER[taskKey] = {};

  const gps = LAST_KNOWN_GPS;
  if (!gps || !gps.latitude) {
    alert("üìç Waiting for GPS signal...");
    return;
  }
    
  let blob;
  try {
    blob = await compressImage(file, gps, new Date().toISOString());
  } catch {
    alert("Image processing failed");
    return;
  }

  

  const previewURL = URL.createObjectURL(blob);
  
  PHOTO_BUFFER[taskKey][photoIndex] = {
    blob,
    previewURL,
    takenAt: new Date().toISOString(),
    gps,
    deliveryData: BILLING_CACHE[taskKey] || {}
  };

  await savePhotoToDB({
    id: `${taskKey}_${photoIndex}`,
    taskKey: taskKey,
    photoIndex: photoIndex,
    blob,
    takenAt: new Date().toISOString(),
    gps,
    deliveryData: BILLING_CACHE[taskKey] || {},
    submitIntent: false
  });
  
  setTimeout(checkStorageQuota, 0);

  // üîí Lock UI to this task after first photo
  if (photoIndex === 1) {
    ACTIVE_CAPTURE_TASK = taskKey;
  }

  CURRENT_PHOTO_INDEX = null;
  CURRENT_TASK = null;   // üî• REQUIRED FIX
  
  // ‚úÖ reset AFTER capture finishes
  setTimeout(() => {
    cameraInput.value = "";
  }, 150);
  // ‚úÖ LOCAL UI UPDATE ONLY ‚Äî NO FULL RELOAD
  applyFiltersOnly()
  } catch (err) {
      console.error("üì∏ Camera handler crash:", err);
      alert("Camera error ‚Äî please retry.");
    }
  };
  
  window.submitTask = async function(taskKey) {

  if (submitLock[taskKey]) return;
  submitLock[taskKey] = true;

  const btn = document.querySelector(
    `button[onclick="submitTask('${taskKey}')"]`
  );

  if (btn) {
    btn.disabled = true;
    btn.innerText = "‚è≥ Uploading...";
  }

  const photos = PHOTO_BUFFER[taskKey];

  if (!photos || Object.keys(photos).length === 0) {
    alert("Please take at least 1 photo.");
    submitLock[taskKey] = false;
    if (btn) {
      btn.disabled = false;
      btn.innerText = "‚úÖ Submit Task";
    }
    return;
  }

  // ==============================
  // ‚úÖ ALWAYS QUEUE (ONLINE OR OFFLINE)
  // ==============================
  
  
  
  // üîÅ STORE QUEUE ENTRY
  let q = getQueue().filter(x => x.taskKey !== taskKey);
  q.push({ taskKey });
  setQueue(q);

  await saveTasksToIndexedDB([{
    _key: taskKey,
    status: "LOCAL_COMPLETED",
    driverId: DRIVER_ID,
    dateKey: dateFilter.value.replace(/-/g, "")
  }]);

  // üîì MARK ALL INDEXEDDB PHOTOS FOR THIS TASK AS SUBMITTED
    const dbi = await openDB();
    
    await new Promise((resolve, reject) => {
      const tx = dbi.transaction(STORE, "readwrite");
      const store = tx.objectStore(STORE);
    
      const req = store.getAll();
    
      req.onsuccess = () => {
        req.result
          .filter(p => p.taskKey === taskKey)
          .forEach(p => {
            store.put({
              ...p,
              submitIntent: true
            });
          });
      };
    
      tx.oncomplete = resolve;
      tx.onerror = reject;
    });
  
  // üß† Photos already saved to IndexedDB at capture time
  delete PHOTO_BUFFER[taskKey];
  ACTIVE_CAPTURE_TASK = null;
  
  delete processingMap[taskKey];
  delete uploadingMap[taskKey];
  updateRefreshLock();
  
  loadTasks();
  
  submitLock[taskKey] = false;
  if (btn) {
    btn.disabled = false;
    btn.innerText = "‚úÖ Submit Task";
  }
  
  
  return;

  // ==============================
  // ‚úÖ ONLINE MODE (CURRENT FLOW)
  // ==============================

  processingMap[taskKey] = true;
  loadTasks();

  try {
    const indices = Object.keys(photos).map(Number).sort((a,b)=>a-b);
  
    for (const i of indices) {
      const p = photos[i];
  
      await uploadNow(
        taskKey,
        p.blob,
        p.takenAt,
        null,
        p.deliveryData,
        p.gps,
        i,
        i === indices[indices.length - 1]   // ‚úÖ last upload flag
      );
    }

    // üß† FREE ALL PREVIEW MEMORY AFTER SUBMIT
    if (PHOTO_BUFFER[taskKey]) {
      Object.values(PHOTO_BUFFER[taskKey]).forEach(p => {
        if (p.previewURL) URL.revokeObjectURL(p.previewURL);
      });
    }
    
    delete PHOTO_BUFFER[taskKey];
    delete processingMap[taskKey];
    ACTIVE_CAPTURE_TASK = null;
    updateRefreshLock();
    
    loadTasks();

  } catch (e) {
    console.error(e);
    alert("‚ùå Upload failed.");
  }

  delete submitLock[taskKey];
};


/* ===== CAMERA ===== */

function saveToGallery(blob, filename) {
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = filename;

  document.body.appendChild(a);
  a.click();

  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

window.CURRENT_TASK = null;


  
function updateRefreshLock() {
  if (isBusy()) {
    disablePullToRefresh();
  } else {
    enablePullToRefresh();
  }
}

function resolveStatus(task) {
  if (task.status === "COMPLETED") return "COMPLETED";
  if (task.status === "LOCAL_COMPLETED") return "SYNC_PENDING";

  if (uploadingMap[task._key]) return "UPLOADING";
  if (processingMap[task._key]) return "PROCESSING";

  const p = PHOTO_BUFFER[task._key];
  if (p && Object.keys(p).length > 0) return "READY";

  return "PENDING";
}
 

function removeTaskFromUI(taskKey) {
  TASKS_CACHE = TASKS_CACHE.filter(t => t._key !== taskKey);
  applyFiltersOnly();
}

function sortTasksOfflineSafe(tasks) {
  function getOfflineRank(t) {
    if (t.status === "OFFLINE_PENDING") return 3;
    if (t.status === "UPLOADING") return 2;

    const resolved = resolveStatus(t);
    if (resolved === "READY") return 1;
    if (resolved === "PENDING") return 1;

    return 9;
  }

  return tasks.sort((a, b) => {
    const ra = getOfflineRank(a);
    const rb = getOfflineRank(b);

    if (ra !== rb) return ra - rb;

    // secondary: oldest first
    return new Date(a.createdAt || 0) - new Date(b.createdAt || 0);
  });
}

async function uploadNow(
    taskKey,
    blob,
    takenAt,
    _ignoredFilename,
    deliveryData = {},
    photoGPS,
    photoIndex,
    isLastPhoto
  ) {
  const taskSnap = await get(ref(db, `tasks/${taskKey}`));
  const task = taskSnap.val() || {};

  if (!photoGPS || !photoGPS.latitude) {
    throw new Error("GPS_REQUIRED_AT_PHOTO_TIME");
  }

  // ===== BUILD FILENAME =====
  const safe = v => String(v || "")
    .toUpperCase()
    .replace(/[^A-Z0-9]+/g, "_")
    .replace(/^_|_$/g, "");

  const filename =
  `${safe(task.CUSTOMERNAME)}_${safe(task.ADDRESS)}_` +
  `P${photoIndex}_` +
  `${photoGPS.longitude}_${photoGPS.latitude}_` +
  `${task.driverId}_${new Date().toISOString()
    .replace(/[-:T.Z]/g, "")
    .slice(0,14)}.jpg`;
  

  // üîÅ MARK LAST UPLOAD ATTEMPT (VERY IMPORTANT)
  await update(ref(db, `tasks/${taskKey}`), {
    lastUploadAttemptAt: new Date().toISOString()
  });

  // ===== UPLOAD =====
  const imgRef = sRef(storage, `tasks/${taskKey}/${filename}`);
  await uploadBytes(imgRef, blob);
  const url = await getDownloadURL(imgRef);

  // ===== FLATTEN DATA =====
  const updatePayload = {
  ...(isLastPhoto ? { status: "COMPLETED", forceReopen: false } : {}),
    [`photo${photoIndex}Url`]: url,
    [`photo${photoIndex}Filename`]: filename,
    [`photo${photoIndex}TakenAt`]: takenAt,
    uploadedAt: new Date().toISOString(),
    deliveryType: deliveryData.deliveryType || ""
  };

  for (const [k, v] of Object.entries(deliveryData)) {
  if (k === "deliveryType") continue;

  if (k === "deliverytype_2nd") {
    updatePayload[k] = v;
    continue;
  }

  // append _2nd for radio child inputs
  const finalKey = deliveryData.deliverytype_2nd ? `${k}_2nd` : k;

  updatePayload[finalKey] = v;
}

  if (photoGPS && photoGPS.latitude) {
    updatePayload.LATITUDE  = photoGPS.latitude;
    updatePayload.LONGITUDE = photoGPS.longitude;
    updatePayload.gpsAccuracy = photoGPS.accuracy || null;
  }

  await update(ref(db, `tasks/${taskKey}`), updatePayload);
  // ‚úÖ SAVE TO GALLERY ONLY AFTER SUCCESS
  try {
    saveToGallery(blob, filename);
  } catch (e) {
    console.warn("Gallery save failed", e);
  }
  if (isLastPhoto) {
    await deleteTaskFromIndexedDB(taskKey);
    markTaskCompletedInCache(taskKey);
    updateUploadCounter(TASKS_CACHE);
    updateRemainingCounter(TASKS_CACHE);
    removeTaskFromUI(taskKey);
  }
  // ‚úÖ THIS WAS MISSING
  delete processingMap[taskKey];
  delete uploadingMap[taskKey];
  updateRefreshLock()
  

  // ===============================
// ‚úÖ ADMIN STATS UPDATE (ONCE)
// ===============================
if (isLastPhoto) {
  const dateKey =
    task.dateKey ||
    normalizeDatePH(task.createdAt)?.replace(/-/g, ""); 
  if (dateKey) {
    const statsRef = ref(db, `adminStats/${dateKey}`);

    try {
      await update(statsRef, {
        open: increment(-1),
        done: increment(1)
      });
    } catch (e) {
      console.warn("‚ö†Ô∏è adminStats update failed", e);
      // ‚ùó DO NOT BLOCK DRIVER FLOW
    }
  }
}


/* ================= FIX #3 START ================= */


/* ================= FIX #3 END ================= */
  // ‚úÖ CLEAR FORM CACHE AFTER SUCCESS
  const forms = loadFormCache();
  if (!jobTypeFilterInitialized) {
    selectedJobTypes.clear();
  }
  delete forms[taskKey];
  saveFormCache(forms);
  
  updateRefreshLock();
}

async function preloadDriverUIConfig(tasks) {
  const types = new Set(
    tasks.map(t => t.JOBTYPE).filter(Boolean)
  );

  await Promise.all(
    [...types].map(t => loadDriverUI(t))
  );
}
  
checkStorageQuota();
setInterval(checkStorageQuota, 60_000); // every 60 seconds

  
async function loadTasks() {
  if (LOAD_IN_PROGRESS) return;
  LOAD_IN_PROGRESS = true;

  const selectedDate = dateFilter.value;
  if (!selectedDate) {
    taskList.innerHTML = "Select a date.";
    LOAD_IN_PROGRESS = false;
    return;
  }

  const dateKey = selectedDate.replace(/-/g, "");

  try {
    // ===============================
    // 1Ô∏è‚É£ ALWAYS READ INDEXEDDB FIRST
    // ===============================
    const cached = await getTasksFromIndexedDB();

    const localTasks = cached.filter(t =>
      t.dateKey === dateKey &&
      String(t.driverId || "").trim().toUpperCase() ===
      String(DRIVER_ID).trim().toUpperCase() &&
      resolveStatus(t) !== "COMPLETED"
    );

    if (!navigator.onLine) {
      // üîí OFFLINE MODE
      if (!localTasks.length) {
        TASKS_CACHE = [];
        renderWithPagination([]);
        updateRemainingCounter([]);
        updateUploadCounter([]);
        toggleJobTypeFilter(false);
        taskList.innerHTML = "üì≠ No tasks found for selected date.";
        LOAD_IN_PROGRESS = false;
        return;
      }

      TASKS_CACHE = sortTasksOfflineSafe(localTasks);
      selectedJobTypes.clear();
      jobTypeFilterInitialized = false;
      renderJobTypeFilters(TASKS_CACHE);
      refreshUI();
      LOAD_IN_PROGRESS = false;
      return;
    }

    // ===============================
    // 2Ô∏è‚É£ CACHE-FIRST STRICT MODE
    // ===============================
    
    const hasLocalTasks = localTasks.length > 0;
    
    if (!FORCE_REDOWNLOAD && hasLocalTasks) {
      TASKS_CACHE = sortTasksOfflineSafe(localTasks);
    
      selectedJobTypes.clear();
      jobTypeFilterInitialized = false;
      renderJobTypeFilters(TASKS_CACHE);
      refreshUI();
    
      LOAD_IN_PROGRESS = false;
      return; // ‚õî STOP ‚Äî DO NOT FETCH FIREBASE
    }

    // ===============================
    // 3Ô∏è‚É£ FETCH FROM FIREBASE
    // ===============================
    const idsSnap = await get(ref(db, `tasksByDate/${dateKey}`));
    const ids = Object.keys(idsSnap.val() || {});

    if (!ids.length) {

      if (!localTasks.length) {
        TASKS_CACHE = [];
        renderWithPagination([]);
        updateRemainingCounter([]);
        updateUploadCounter([]);
        toggleJobTypeFilter(false);
    
        taskList.innerHTML = `
          üì≠ No tasks found for selected date.<br><br>
          <small>
            Date: ${selectedDate}<br>
            Driver: ${DRIVER_ID}
          </small>
        `;
      }
    
      LOAD_IN_PROGRESS = false;
      return;
    }

    const reads = ids.map(async id => {
      const s = await get(ref(db, `tasks/${id}`));
      if (!s.exists()) return null;

      const task = s.val();

      if (
        String(task.driverId || "").trim().toUpperCase() !==
        String(DRIVER_ID).trim().toUpperCase()
      ) return null;

      if (task.status === "COMPLETED") return null;

      return { _key: id, ...task, dateKey };
    });

    let freshTasks = (await Promise.all(reads)).filter(Boolean);

    if (ids.length > 0 && freshTasks.length === 0) {
        taskList.innerHTML = `
          ‚ö† Tasks exist for this date,
          but none assigned to Driver ID: <b>${DRIVER_ID}</b>
          <br><br>
          Check ‚öôÔ∏è Driver ID setting.
        `;
        LOAD_IN_PROGRESS = false;
        return;
      }

    if (!freshTasks.length) {
      if (!localTasks.length) {
        TASKS_CACHE = [];
        renderWithPagination([]);
        updateRemainingCounter([]);
        updateUploadCounter([]);
        toggleJobTypeFilter(false);
        taskList.innerHTML = "üì≠ No tasks found for selected date.";
      }
      LOAD_IN_PROGRESS = false;
      return;
    }

    // ===============================
    // 4Ô∏è‚É£ SAVE TO INDEXEDDB
    // ===============================
    await saveTasksToIndexedDB(freshTasks);

    TASKS_CACHE = sortTasksOfflineSafe(freshTasks);

    selectedJobTypes.clear();
    jobTypeFilterInitialized = false;
    renderJobTypeFilters(TASKS_CACHE);

    refreshUI();

  } catch (err) {
  console.error("‚ùå loadTasks error:", err);

  let reason = "";

  if (!navigator.onLine) {
    reason = "üì¥ You are offline.";
  } else if (err?.message?.includes("permission")) {
    reason = "üîí Permission denied. Check Firebase rules.";
  } else if (err?.message?.includes("network")) {
    reason = "üåê Network error while contacting server.";
  } else if (err?.message?.includes("timeout")) {
    reason = "‚è≥ Request timed out.";
  } else {
    reason = err?.message || "Unknown error.";
  }

  taskList.innerHTML = `
    ‚ö† <b>Failed to load tasks</b><br><br>
    <div style="font-size:12px;opacity:.8">
      ${reason}
    </div>
    <br>
    <button onclick="loadTasks()"
      style="padding:8px;border:none;border-radius:6px;background:#3498db;color:#fff">
      üîÑ Try Again
    </button>
  `;
}

  LOAD_IN_PROGRESS = false;
}

document.getElementById("refreshTasksBtn").onclick = async () => {
  if (!navigator.onLine) {
    alert("üì¥ You are offline.\n\nConnect to the internet to download tasks.");
    return;
  }

  if (LOAD_IN_PROGRESS) {
    alert("‚è≥ Tasks are already loading.");
    return;
  }

  const ok = confirm(
    "üîÑ Download tasks from server?\n\n" +
    "This will refresh today‚Äôs task list.\n" +
    "Offline photos will NOT be lost."
  );

  if (!ok) return;

  FORCE_REDOWNLOAD = true;

  taskList.innerHTML = "‚è¨ Downloading tasks‚Ä¶";

  await loadTasks();

  FORCE_REDOWNLOAD = false;
};


async function detectGPSPermission() {
  if (!navigator.permissions) return;

  try {
    const result = await navigator.permissions.query({ name: "geolocation" });

    if (result.state === "denied") {
      gpsStatus.innerText =
        "üö´ Location blocked ‚Äî Tap ‚öôÔ∏è ‚Üí Allow Location";
    }

    result.onchange = () => detectGPSPermission();
  } catch {}
}

function handleGPSError(err) {
  const gpsStatus = document.getElementById("gpsStatus");

  let msg = "";

  switch (err.code) {
    case 1:
      msg = "üö´ Location blocked ‚Äî Phone Settings ‚Üí App ‚Üí Allow Location (Always)";
      break;

    case 2:
      msg = "üì¥ GPS is OFF ‚Äî Turn ON Location services";
      break;

    case 3:
      msg = "‚è≥ Can't get GPS ‚Äî Move to open area & wait";
      break;

    default:
      msg = "‚ö†Ô∏è GPS error ‚Äî Restart phone";
  }

  if (gpsStatus) gpsStatus.innerText = msg;
}

function updateUploadCounter(tasks) {
  if (!Array.isArray(tasks)) return;

  const uploadingCount = tasks.filter(t => {
    const status = resolveStatus(t);
    return (
      status === "SYNC_PENDING" ||
      status === "PROCESSING" ||
      status === "UPLOADING"
    );
  }).length;

  const el = document.getElementById("uploadCounter");
  const note = document.getElementById("uploadNote");
  const retryBtn = document.getElementById("retryUploadBtn");
  const refreshBtn = document.getElementById("refreshTasksBtn");

  if (!el || !refreshBtn) return;

  if (uploadingCount > 0) {
    // üîº Upload UI
    el.innerText = `‚è´ Pending Uploads: ${uploadingCount}`;
    el.style.display = "block";

    if (note) note.style.display = "block";
    if (retryBtn) retryBtn.style.display = "block";

    // üîí LOCK REFRESH
    refreshBtn.disabled = true;
    refreshBtn.style.opacity = "0.6";
    refreshBtn.innerText = "‚è≥ Upload in progress‚Ä¶";

  } else {
    // ‚úÖ Clear upload UI
    el.innerText = "";
    el.style.display = "none";

    if (note) note.style.display = "none";
    if (retryBtn) retryBtn.style.display = "none";

    // üîì UNLOCK REFRESH
    refreshBtn.disabled = false;
    refreshBtn.style.opacity = "1";
    refreshBtn.innerText = "üîÑ Download / Refresh Tasks";
  }
}
  
function updateRemainingCounter(tasks) {
  const selectedDate =
    document.getElementById("dateFilter")?.value;

  if (!selectedDate) return;

  const remaining = tasks.filter(t => {
    const status = resolveStatus(t);

    // ‚úÖ pending only
    if (status !== "PENDING") return false;

    // ‚úÖ must match selected date
    const dateKey = selectedDate.replace(/-/g, "");
      if (t.dateKey !== dateKey) return false;

    return true;
  }).length;

  const el = document.getElementById("taskCounter");
  if (el && !IS_DOWNLOADING) {
    el.innerText = `üìÑ Remaining Tasks: ${remaining}`;
  }
}  

  const INITIAL_RENDER_COUNT = 1;   // show 1 card immediately
 function renderWithPagination(tasks) {
  CURRENT_RENDER_LIST = tasks;
  RENDER_OFFSET = 0;

  // Clear list safely
  taskList.innerHTML = "";

  // Always re-attach sentinel at bottom
  taskList.appendChild(sentinel);

  // Start rendering first chunk
  requestAnimationFrame(renderNextPage);
}
const RENDER_CHUNK_SIZE = 3;      // then render 3 per frame

function renderOneTask(t) {
  if (!t || !t._key) return;
  const p = PHOTO_BUFFER[t._key] || {};
  // ‚úÖ RESTORE FORM STATE IF EXISTS
  const savedForms = loadFormCache();
  if (savedForms[t._key] && !BILLING_CACHE[t._key]) {
    BILLING_CACHE[t._key] = savedForms[t._key];
  }
  if (!BILLING_CACHE[t._key]) {
    BILLING_CACHE[t._key] = {};
  }

  const status = resolveStatus(t);

  const div = document.createElement("div");
  div.className = `task ${status === "COMPLETED" ? "completed" : ""}`;

  const hasGPS =
    t.LATITUDE &&
    t.LONGITUDE &&
    !isNaN(parseFloat(t.LATITUDE)) &&
    !isNaN(parseFloat(t.LONGITUDE));

  const mapURL = hasGPS
    ? `https://www.google.com/maps?q=${t.LATITUDE},${t.LONGITUDE}`
    : null;

  const addressHTML = hasGPS
    ? `<a href="${mapURL}" target="_blank"
        style="color:#007bff;text-decoration:underline;font-weight:bold;">
        üìç ${t.ADDRESS || "‚Äî"}
      </a>`
    : `<div>üìç ${t.ADDRESS || "‚Äî"}</div>`;

  let html = `
    <b>${t.CUSTOMERNAME || "‚Äî"}</b>
    <div class="small">${addressHTML}</div>
    <div class="small"><b>Account #:</b> ${t.ACCOUNTNUMBER || "‚Äî"}</div>
    <div class="small"><b>MRU:</b> ${t.MRU || "‚Äî"}</div>
    <div class="small"><b>Meter #:</b> ${t.METERNUMBER || "‚Äî"}</div>
    <div class="small"><b>DMZ:</b> ${t.DMZ || "‚Äî"}</div>
    <div class="small"><b>Sequence:</b> ${t.SEQUENCE || "‚Äî"}</div>
    <div class="small"><b>Job Type:</b> ${t.JOBTYPE || "‚Äî"}</div>
    <div class="small"><b>Status:</b> ${status}</div>
  `;
  html += `<div id="delivery_${t._key}"></div>`;
  if (t.lastUploadAttemptAt) {
    html += `
      <div class="small" style="color:#888">
        ‚è± Last upload attempt:
        ${new Date(t.lastUploadAttemptAt).toLocaleTimeString()}
      </div>
    `;
  }

  /* ===== PENDING (EDITABLE ONLINE + OFFLINE) ===== */
  if ((status === "PENDING" || status === "CAPTURING" || status === "READY") && !t.finalized) {
    const count = Object.keys(p).length;

    if (count > 0) {
      html += `
        <div class="uploading" style="color:green;">
          üì∏ Photos taken: ${count} ‚Äî you may submit
        </div>
      `;
    }
    

    /* ===== PREVIEW THUMBNAILS ===== */
    const previews = [1,2,3].map(i => {
      if (!p[i]?.previewURL) return "";
      return `
        <img src="${p[i].previewURL}"
          onclick="window.open('${p[i].previewURL}','_blank')"
          style="
            width:100%;
            max-width:100px;
            height:80px;
            object-fit:cover;
            border-radius:6px;
            border:2px solid #28a745;
            cursor:pointer;
          "
        />
      `;
    }).join("");

    if (previews) {
      html += `
        <div style="
          display:grid;
          grid-template-columns:repeat(3,1fr);
          gap:6px;
          margin-top:8px;
        ">
          ${previews}
        </div>
      `;
    }

    /* ===== PHOTO BUTTONS ===== */
    const disable1 = !!p[1];
    const disable2 = !p[1] || !!p[2];
    const disable3 = !p[2] || !!p[3];
    const disableSubmit = Object.keys(p).length === 0;

    html += `
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-top:8px;">
        <button ${disable1 ? "disabled" : ""}
          onclick="startPhoto(1,'${t._key}')">
          üì∏ Photo 1
        </button>

        <button ${disable2 ? "disabled" : ""}
          onclick="startPhoto(2,'${t._key}')">
          üì∏ Photo 2
        </button>

        <button ${disable3 ? "disabled" : ""}
          onclick="startPhoto(3,'${t._key}')">
          üì∏ Photo 3
        </button>
      </div>

      <button ${disableSubmit ? "disabled" : ""}
        onclick="submitTask('${t._key}')">
        ‚úÖ Submit Task
      </button>
    `;
  }

  if (status === "SYNC_PENDING") {
    html += `
      <div class="uploading">
        üì¶ Saved safely ‚Äî will auto-upload when signal is stable,keep app open while uploading
      </div>
    `;
  }

  if (status === "UPLOADING") {
    html += `<div class="uploading">‚è≥ Uploading photo‚Ä¶</div>`;
  }

  if (status === "COMPLETED") {
    html += `
      <button class="toggle"
        onclick="
          const img = this.parentElement.querySelector('img');
          if (!img) return;
          img.style.display = img.style.display === 'none'
            ? 'block'
            : 'none';
        ">
        üëÅ Show / Hide Photo
      </button>

      <img src="${t.imageUrl}" style="display:none">
    `;
  }

  div.innerHTML = html;
taskList.appendChild(div);

// ‚úÖ NOW the container exists
if (
  (status === "PENDING" || status === "CAPTURING" || status === "READY") &&
  !t.finalized &&
  ACTIVE_CAPTURE_TASK !== t._key
) {
  renderDynamicDelivery(t).then(h => {
    if (!document.body.contains(div)) return;
    const target = div.querySelector(`#delivery_${t._key}`);
    if (target && h) {
      target.innerHTML = h;
    }
  });
}
}


let RENDERING = false;

async function renderNextPage() {
  if (RENDERING) return;
  if (RENDER_OFFSET >= CURRENT_RENDER_LIST.length) return;

  RENDERING = true;

  const start = RENDER_OFFSET;
  const end = Math.min(start + RENDER_CHUNK_SIZE, CURRENT_RENDER_LIST.length);

  for (let i = start; i < end; i++) {
    renderOneTask(CURRENT_RENDER_LIST[i]);
  }

  RENDER_OFFSET = end;
  RENDERING = false;

  // ‚úÖ Auto-fill screen until scrollable
  requestAnimationFrame(() => {
    const doc = document.documentElement;

    const notScrollable =
    doc.scrollHeight <= window.innerHeight + 150;

    if (
      notScrollable &&
      RENDER_OFFSET < CURRENT_RENDER_LIST.length
    ) {
      renderNextPage();
    }
  });
}

function canUploadNow() {
  if (!navigator.onLine) return false;

  if (navigator.connection) {
    const c = navigator.connection;
    
    if (c.effectiveType === "2g" || c.effectiveType === "slow-2g") {
      return false;
    }
  }
  return true;
}
function matchesSearch(task, term) {
  if (!term) return true;
  term = term.toLowerCase();

  return (
    String(task.CUSTOMERNAME || "").toLowerCase().includes(term) ||
    String(task.ADDRESS || "").toLowerCase().includes(term) ||
    String(task.ACCOUNTNUMBER || "").toLowerCase().includes(term) ||
    String(task.METERNUMBER || "").toLowerCase().includes(term) ||
    String(task.DMZ || "").toLowerCase().includes(term) ||
    String(task.SEQUENCE || "").toLowerCase().includes(term)
  );
}
  
async function renderDynamicDelivery(t) {
  const methods = await loadDriverUI(t.JOBTYPE);
  if (!methods || typeof methods !== "object") return "";

  const methodNames = Object.keys(methods);
  if (!methodNames.length) return "";

  let html = `<div class="radio-group"><b>Delivery Method</b>`;

  for (const m of methodNames) {
    html += `
      <label>
        <input type="radio" name="delivery_${t._key}" value="${m}"
          onchange="handleDeliveryMethod('${t._key}','${t.JOBTYPE}','${m}')">
        ${m}
      </label>`;
  }

  html += `</div><div id="dyn_${t._key}"></div>`;
  // üîÅ Restore selected delivery method UI
  const saved = BILLING_CACHE[t._key];
  if (saved?.deliveryType) {
    setTimeout(() => {
      const radio = document.querySelector(
        `input[name="delivery_${t._key}"][value="${saved.deliveryType}"]`
      );
      if (radio) radio.checked = true;
    }, 0);
  }
  // üîÅ Auto-rebuild child fields if previously selected
if (saved?.deliveryType && saved?.deliverytype_2nd) {
  setTimeout(() => {
    handleDeliveryMethod(
      t._key,
      t.JOBTYPE,
      saved.deliveryType
    );

    setTimeout(() => {
      handleRadioTrigger(
        t._key,
        t.JOBTYPE,
        saved.deliveryType,
        saved.deliverytype_2nd
      );
    }, 0);
  }, 0);
}
  return html;
}

  
function getCurrentLocation() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject("Geolocation not supported");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      pos => {
        resolve({
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude
        });
      },
      err => reject(err.message),
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      }
    );
  });
}

const sentinel = document.getElementById("scrollSentinel");

const observer = new IntersectionObserver(entries => {
  if (entries[0].isIntersecting) {
    if (!RENDERING && RENDER_OFFSET < CURRENT_RENDER_LIST.length) {
      renderNextPage();
    }
  }
}, {
  root: null,
  rootMargin: "300px",
  threshold: 0
});

observer.observe(sentinel);

function dedupeTasks(tasks) {
  const map = new Map();

  const rank = {
    PENDING: 1,
    OFFLINE_PENDING: 2,
    PROCESSING: 3,
    UPLOADING: 4,
    COMPLETED: 5
  };

  for (const t of tasks) {
    if (!t || !t._key) continue;

    const prev = map.get(t._key);
    if (!prev) {
      map.set(t._key, t);
    } else {
      const r1 = rank[prev.status] || 0;
      const r2 = rank[t.status] || 0;

      if (r2 >= r1) map.set(t._key, t);
    }
  }

  return [...map.values()];
}
  
async function validateDynamic(taskKey) {
  syncDynamicFields(taskKey);

  // üî• SOURCE OF TRUTH = IndexedDB
  const tasks = await getTasksFromIndexedDB();
  const task = tasks.find(t => t._key === taskKey);

  if (!task) {
    alert("Task not found for selected date.\n\nTry changing date or refreshing.");
    return false;
  }

  const data = BILLING_CACHE[taskKey];

  // 1Ô∏è‚É£ Delivery method required
  if (!data?.deliveryType) {
    alert("Select delivery method");
    return false;
  }

  // 2Ô∏è‚É£ Config MUST exist (offline-safe)
  const jobCfg = DRIVER_UI_CACHE[task.JOBTYPE];
  if (!jobCfg) {
    alert("Delivery configuration not available. Please go online once.");
    return false;
  }

  const methodCfg = jobCfg[data.deliveryType];
  if (!methodCfg) {
    alert("Invalid delivery method. Please reselect.");
    return false;
  }

  // 3Ô∏è‚É£ Direct fields
  for (const key of methodCfg._order || []) {
    const field = methodCfg.fields[key];
    if (field.type === "radio") continue;
    if (field.required && !data[key]) {
      alert(`${field.label} is required`);
      return false;
    }
  }

  // 4Ô∏è‚É£ Radio child fields
  const selectedRadio = data.deliverytype_2nd;
  if (selectedRadio) {
    const radioField = methodCfg.fields[selectedRadio];
    const childOrder = radioField?.fields?._order || [];

    for (const k of childOrder) {
      const f = radioField.fields.options[k];
      if (f.required && !data[k]) {
        alert(`${f.label} is required`);
        return false;
      }
    }
  }

  return true;
} 
  
// ‚è≥ Prevent infinite loading screen (BOOT SAFETY)
setTimeout(() => {
  if (
    !BOOT_WATCHDOG_FIRED &&
    taskList &&
    taskList.innerText.includes("Loading")
  ) {
    taskList.innerHTML =
      "üì≠ No tasks found for selected date.<br><br>" +
      "<small>If this is unexpected, open ‚öôÔ∏è and verify Driver ID.</small>";
    BOOT_WATCHDOG_FIRED = true;
  }
}, 8000);

// üßπ BOOT CLEANUP ‚Äî REMOVE COMPLETED TASKS FROM INDEXEDDB
(async () => {
  const tasks = await getTasksFromIndexedDB();
  for (const t of tasks) {
    if (t.status === "COMPLETED") {
      await deleteTaskFromIndexedDB(t._key);
    }
  }
})();

// üßπ PRUNE OLD / INVALID TASKS
await pruneOldTasks();

// üöÄ INITIAL BOOT LOAD
loadTasks();


function markTaskCompletedInCache(taskKey) {
  const t = TASKS_CACHE.find(x => x._key === taskKey);
  if (t) {
    t.status = "COMPLETED";
  }
}

let startY = 0;

window.addEventListener(
  "touchstart",
  e => {
    if (e.touches.length === 1) {
      startY = e.touches[0].clientY;
    }
  },
  { passive: true }
);

window.handleDeliveryMethod = async function(taskKey, jobType, method) {
  if (!BILLING_CACHE[taskKey]) BILLING_CACHE[taskKey] = {};
    BILLING_CACHE[taskKey].deliveryType = method;

  const cfg = await loadDriverUI(jobType);
  const block = cfg?.[method];
  const box = document.getElementById(`dyn_${taskKey}`);

  if (!box || !block) return;
  box.innerHTML = "";

  let html = "";

  for (const key of block._order || []) {
    const field = block.fields[key];
    if (!field) continue;

    const req = field.required ? " *" : "";

    // TEXT / TEXTAREA
    if (field.type === "text" || field.type === "textarea") {
      if (field.type === "textarea") {
        html += `
          <div class="delivery-fields">
            <label>${field.label}${req}</label>
            <textarea data-key="${key}"
              oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value"></textarea>
          </div>`;
      } else {
        html += `
          <div class="delivery-fields">
            <label>${field.label}${req}</label>
            <input type="text" data-key="${key}"
              oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value"/>
          </div>`;
      }
    }

    // RADIO TRIGGER
    if (field.type === "radio") {
      html += `
        <div class="radio-group">
          <label>
            <input type="radio"
              name="radio_${taskKey}"
              value="${key}"
              onchange="handleRadioTrigger('${taskKey}','${jobType}','${method}','${key}')">
            ${field.label}
          </label>
        </div>
      `;
    }
  }

  html += `<div id="sub_${taskKey}"></div>`;
  box.innerHTML = html;
  saveFormCache({
  ...loadFormCache(),
  [taskKey]: BILLING_CACHE[taskKey]
});
};

window.handleRadioTrigger = async function(taskKey, jobType, method, radioKey) {
  BILLING_CACHE[taskKey].deliverytype_2nd = radioKey;
  const cfg = await loadDriverUI(jobType);
  const radioBlock = cfg?.[method]?.fields?.[radioKey];
  const box = document.getElementById(`sub_${taskKey}`);

  if (!box) return;

  // üî• CLEAR OLD CHILD UI
  box.innerHTML = "";

  // üî• REMOVE OLD CHILD DATA
  syncDynamicFields(taskKey);

  // ‚ùå No children ‚Üí STOP
  if (!radioBlock?.fields?._order?.length) return;

  let html = `<div class="delivery-fields">`;

  for (const key of radioBlock.fields._order) {
    const field = radioBlock.fields.options[key];
    const req = field.required ? " *" : "";

    if (field.type === "textarea") {
      html += `
        <label>${field.label}${req}</label>
        <textarea data-key="${key}"
          oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value"></textarea>`;
    } else {
      html += `
        <label>${field.label}${req}</label>
        <input type="text" data-key="${key}"
          oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value">`;
    }
  }

  html += `</div>`;
  box.innerHTML = html;
};
  
window.addEventListener(
  "touchmove",
  e => {
    const y = e.touches[0].clientY;
    const pullingDown = y > startY;

    if (pullingDown && window.scrollY === 0 && isBusy()) {
      e.preventDefault();
    }
  },
  { passive: false }
);
  
</script>

<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js");
}
</script>

<script>
let deferredPrompt = null;

function isStandalone() {
  return window.matchMedia("(display-mode: standalone)").matches ||
         window.navigator.standalone === true;
}

window.addEventListener("beforeinstallprompt", e => {
  // already installed ‚Üí do nothing
  if (isStandalone()) return;

  e.preventDefault();
  deferredPrompt = e;

  // prevent duplicates
  if (document.getElementById("installBtn")) return;

  const btn = document.createElement("button");
  btn.id = "installBtn";
  btn.innerText = "üì≤ Install Driver App";
  btn.style = `
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 420px;
    padding: 14px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 10px;
    border: none;
    background: #007bff;
    color: #fff;
    z-index: 99999;
  `;

  btn.onclick = async () => {
    btn.disabled = true;
    await deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    btn.remove();
    deferredPrompt = null;
  };

  document.body.appendChild(btn);
});
</script>

<script>
window.addEventListener("appinstalled", () => {
  const btn = document.getElementById("installBtn");
  if (btn) btn.remove();
});
</script>

</body>
</html>
