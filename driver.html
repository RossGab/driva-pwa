
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Driver Tasks</title>

<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#222222">

<style>
body { font-family: Arial, sans-serif; background:#f4f4f4; padding:10px; }
#appVersion { background:#222;color:#fff;padding:8px;text-align:center;margin-bottom:6px; }
#offlineBanner { background:#c0392b;color:#fff;padding:6px;text-align:center;margin-bottom:10px;display:none; }
#searchBox { width:100%;padding:10px;margin-bottom:10px;border-radius:6px;border:1px solid #ccc;font-size:14px; }
.task { background:#fff;padding:12px;margin-bottom:10px;border-radius:8px;border-left:5px solid orange; }
.task.completed { border-left-color:green; }
.small { font-size:13px;color:#555;margin-top:4px; }
.radio-group label { display:block;margin-top:4px; }
textarea { width:100%;min-height:60px;margin-top:6px;padding:6px;font-size:14px; }
.offline-indicator { font-weight:bold;color:#c0392b;margin-top:6px; }
.uploading { font-weight:bold;color:#f39c12;margin-top:6px; }
button { width:100%;padding:10px;margin-top:6px;border-radius:6px;border:none;font-size:14px; }
.capture { background:#007bff;color:#fff; }
.capture-label {
  display: block;
  text-align: center;
  background: #007bff;
  color: #fff;
  padding: 12px;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  user-select: none;
}
#jobTypeOptions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
}

.job-type-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  background: #fff;
  border: 1px solid #ddd;
  padding: 6px 10px;
  border-radius: 18px;
  font-size: 13px;
  cursor: pointer;
  user-select: none;
}

.job-type-chip input {
  margin: 0;
}
.uploading,
.offline-indicator {
  pointer-events: none;
}
.task {
  pointer-events: auto;
}
button.capture {
  position: relative;
  z-index: 9999;
  pointer-events: auto;
}
.toggle { background:#0069d9;color:#fff; }
.delivery-fields {
  display: grid;
  grid-template-columns: 1fr;
  gap: 12px;
  margin-top: 10px;
}

.delivery-fields label {
  font-weight: bold;
  font-size: 13px;
}

.delivery-fields input,
.delivery-fields textarea {
  width: 100%;
  padding: 8px;
  font-size: 14px;
  box-sizing: border-box;
}

.delivery-fields textarea {
  min-height: 90px;
  resize: vertical;
}
img { width:100%;margin-top:8px;border-radius:6px; }
</style>
</head>

<body>
<button id="settingsBtn"
  style="
    position: fixed;
    top: 10px;
    right: 10px;
    width: 42px;
    height: 42px;
    border-radius: 50%;
    border: none;
    background: #fff;
    font-size: 20px;
    box-shadow: 0 2px 6px rgba(0,0,0,.2);
    z-index: 99999;
  ">
  ‚öôÔ∏è
</button>

<div id="appVersion"></div>
<div id="gpsStatus"
  style="background:#fff;padding:6px;text-align:center;
         margin-bottom:6px;border-radius:6px;font-size:13px;">
  üì° Acquiring GPS‚Ä¶
</div>
<div id="taskCounter"
   style="background:#fff;padding:8px;text-align:center;
        margin-bottom:10px;border-radius:6px;font-weight:bold;">
</div>
<div id="offlineBanner">‚ö† Offline ‚Äî photos will upload automatically</div>
  <div id="storageBanner"
  style="
    background:#f39c12;
    color:#000;
    padding:8px;
    text-align:center;
    margin-bottom:10px;
    border-radius:6px;
    font-size:13px;
    display:none;
    font-weight:bold;
  ">
  ‚ö† Low storage ‚Äî please free up space to avoid upload issues
</div>
<div id="uploadCounter"
  style="background:#fff;padding:8px;text-align:center;
         margin-bottom:10px;border-radius:6px;
         font-weight:bold;color:#f39c12;">
</div>
<button
  id="retryUploadBtn"
  style="
    display:none;
    width:100%;
    padding:10px;
    margin-bottom:10px;
    border-radius:6px;
    border:none;
    font-size:14px;
    font-weight:bold;
    background:#e67e22;
    color:#fff;
  "
  onclick="manualRetryUploads()"
>
  üîÅ Retry Pending Uploads
</button>

<input
  type="date"
  id="dateFilter"
  style="
    width:100%;
    padding:10px;
    margin-bottom:8px;
    border-radius:6px;
    border:1px solid #ccc;
    font-size:14px;
  "
>
<div id="jobTypeFilter"
  style="
    background:#fff;
    padding:10px;
    margin-bottom:8px;
    border-radius:6px;
    font-size:13px;
  ">
  <b>Job Type</b>
  <div id="jobTypeOptions"></div>
</div>
<input id="searchBox" placeholder="Search tasks">
<div id="taskList">Loading tasks‚Ä¶</div>
<input type="file" id="cameraInput" accept="image/*" capture="environment" hidden>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getDatabase, ref, get, update, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

const VERSION = "Driver v3.5.14.4.0-DYNAMIC";
const BILLING_CACHE = {};
const DRIVER_UI_CACHE = {};
const DRIVER_UI_STORAGE_KEY = "driverUIConfigCache";
const selectedJobTypes = new Set();
const PHOTO_BUFFER = {};
const submitLock = {};
const FORM_CACHE_KEY = "driverFormCache";
let ACTIVE_CAPTURE_TASK = null;
let jobTypeFilterInitialized = false;
let LAST_KNOWN_GPS = null;

const firebaseConfig = {
  apiKey: "AIzaSyDFW61pnwLvh6HGKWt10zLYNr860fI8vkg",
  authDomain: "driva-pwa.firebaseapp.com",
  databaseURL: "https://driva-pwa-default-rtdb.firebaseio.com",
  projectId: "driva-pwa",
  storageBucket: "driva-pwa.firebasestorage.app", // ‚úÖ FIX
  messagingSenderId: "299138219722",
  appId: "1:299138219722:web:623ff6b0a067ea822dfe33"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const storage = getStorage(app);

const QUEUE_KEY = "offlineQueue";
const TASK_CACHE_KEY = "cachedTasks";
const processingMap = {};
const uploadingMap = {};
const DB_NAME = "driver_uploads";
const DB_VERSION = 1;
const STORE = "photos";

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: "id" });
      }
    };

    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function savePhotoToDB(record) {
  const db = await openDB();
  const tx = db.transaction(STORE, "readwrite");
  tx.objectStore(STORE).put(record);
}

async function getAllPhotosFromDB() {
  const db = await openDB();
  return new Promise(resolve => {
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
  });
}

async function deletePhotoFromDB(id) {
  const db = await openDB();
  const tx = db.transaction(STORE, "readwrite");
  tx.objectStore(STORE).delete(id);
}
let SEARCH_TERM = "";
const dateFilter = document.getElementById("dateFilter");

const STORAGE_WARNING_THRESHOLD_MB = 300; // warn below 300 MB

async function checkStorageQuota() {
  // Storage API not supported ‚Üí silently ignore
  if (!navigator.storage || !navigator.storage.estimate) return;

  try {
    const { quota, usage } = await navigator.storage.estimate();
    if (!quota || !usage) return;

    const freeMB = (quota - usage) / (1024 * 1024);
    const banner = document.getElementById("storageBanner");

    if (!banner) return;

    if (freeMB < STORAGE_WARNING_THRESHOLD_MB) {
      banner.style.display = "block";
      banner.innerText =
        `‚ö† Low storage (${Math.round(freeMB)} MB left) ‚Äî please free space to avoid upload issues`;
    } else {
      banner.style.display = "none";
    }
  } catch (e) {
    console.warn("Storage check failed", e);
  }
}

// ‚úÖ Default to today
function getTodayPH() {
  return new Date().toLocaleDateString("en-CA", {
    timeZone: "Asia/Manila"
  });
}

dateFilter.value = getTodayPH();

// Re-load when date changes
dateFilter.addEventListener("change", () => {
  loadTasks();
});

function normalizeDatePH(dateStr) {
  if (!dateStr || typeof dateStr !== "string") return null;

  const d = new Date(dateStr);
  if (isNaN(d.getTime())) return null;

  return d.toLocaleDateString("en-CA", {
    timeZone: "Asia/Manila"
  });
}

function isBusy() {
  const queue = JSON.parse(localStorage.getItem("offlineQueue") || "[]");
  return (
    queue.length > 0 ||
    Object.keys(processingMap).length > 0 ||
    Object.keys(uploadingMap).length > 0
  );
}

searchBox.addEventListener("input", e => {
  SEARCH_TERM = e.target.value.toLowerCase();
  loadTasks(); // re-render with filter
});

let DRIVER_ID = localStorage.getItem("driverId");
while (!DRIVER_ID) DRIVER_ID = prompt("Enter Driver ID");
localStorage.setItem("driverId", DRIVER_ID);

document.getElementById("settingsBtn").onclick = () => {
  const current = localStorage.getItem("driverId") || "";

  const next = prompt("Enter new Driver ID", current);
  if (!next) return;
  if (next === current) return;

  localStorage.setItem("driverId", next);
  alert("Driver ID changed. Reloading‚Ä¶");
  location.reload();
};

let gpsWatchId = null;

appVersion.innerText = `Driver: ${DRIVER_ID} | ${VERSION}`;
startGPSTracking(DRIVER_ID);

async function loadDriverUI(jobType) {
  // 1Ô∏è‚É£ Memory cache
  if (DRIVER_UI_CACHE[jobType]) {
    return DRIVER_UI_CACHE[jobType];
  }

  // 2Ô∏è‚É£ LocalStorage cache
  const stored = JSON.parse(
    localStorage.getItem(DRIVER_UI_STORAGE_KEY) || "{}"
  );

  const cached = stored[jobType];

  // 3Ô∏è‚É£ If offline ‚Üí use cache if available
  if (!navigator.onLine) {
    if (cached) {
      DRIVER_UI_CACHE[jobType] = cached.deliveryMethods || cached;
      return DRIVER_UI_CACHE[jobType];
    }
    return {};
  }

  // 4Ô∏è‚É£ Fetch metadata (updatedAt) FIRST
  const metaSnap = await get(
    ref(db, `config/driverUI/jobTypes/${jobType}/updatedAt`)
  );

  const serverUpdatedAt = metaSnap.val();

  // 5Ô∏è‚É£ Cache HIT + same version ‚Üí reuse
  if (
    cached &&
    cached.updatedAt &&
    serverUpdatedAt &&
    cached.updatedAt === serverUpdatedAt
  ) {
    DRIVER_UI_CACHE[jobType] = cached.deliveryMethods;
    return DRIVER_UI_CACHE[jobType];
  }

  // 6Ô∏è‚É£ Fetch FULL config (changed or first load)
  const snap = await get(
    ref(db, `config/driverUI/jobTypes/${jobType}/deliveryMethods`)
  );

  const deliveryMethods = snap.val() || {};

  // 7Ô∏è‚É£ Save fresh cache
  const payload = {
    updatedAt: serverUpdatedAt || new Date().toISOString(),
    deliveryMethods
  };

  DRIVER_UI_CACHE[jobType] = deliveryMethods;
  stored[jobType] = payload;

  localStorage.setItem(
    DRIVER_UI_STORAGE_KEY,
    JSON.stringify(stored)
  );

  return deliveryMethods;
}

// async function loadDriverUI(jobType) {
//   // 1Ô∏è‚É£ Memory cache
//   if (DRIVER_UI_CACHE[jobType]) return DRIVER_UI_CACHE[jobType];

//   // 2Ô∏è‚É£ LocalStorage cache (OFFLINE SAFE)
//   const stored = JSON.parse(
//     localStorage.getItem(DRIVER_UI_STORAGE_KEY) || "{}"
//   );

//   if (stored[jobType]) {
//     DRIVER_UI_CACHE[jobType] = stored[jobType];
//     return stored[jobType];
//   }

//   // 3Ô∏è‚É£ Online fetch ONLY if online
//   if (!navigator.onLine) {
//     return {}; // offline + no cache = empty
//   }

//   const snap = await get(
//     ref(db, `config/driverUI/jobTypes/${jobType}/deliveryMethods`)
//   );

//   const data = snap.val() || {};

//   // 4Ô∏è‚É£ Save to memory + localStorage
//   DRIVER_UI_CACHE[jobType] = data;
//   stored[jobType] = data;

//   localStorage.setItem(
//     DRIVER_UI_STORAGE_KEY,
//     JSON.stringify(stored)
//   );

//   return data;
// }

function disablePullToRefresh() {
  document.body.style.overscrollBehaviorY = "contain";
}

function enablePullToRefresh() {
  document.body.style.overscrollBehaviorY = "";
}

function renderJobTypeFilters(tasks) {
  const container = document.getElementById("jobTypeOptions");
  if (!container) return;

  const selectedDate = dateFilter.value; // YYYY-MM-DD

  // ‚úÖ COUNT ONLY PENDING TASKS FOR SELECTED DATE
  const jobTypeCounts = {};

  tasks.forEach(t => {
    const status = resolveStatus(t);

    // ‚ùå only pending
    if (status !== "PENDING") return;

    // ‚ùå must match selected date
    const taskDate = normalizeDatePH(t.createdAt);
      if (!taskDate || taskDate !== selectedDate) return;

    if (!t.JOBTYPE) return;

    jobTypeCounts[t.JOBTYPE] =
      (jobTypeCounts[t.JOBTYPE] || 0) + 1;
  });

  const jobTypes = Object.keys(jobTypeCounts).sort();

  container.innerHTML = "";

  jobTypes.forEach(type => {
    const label = document.createElement("label");
    label.className = "job-type-chip";

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";

    // ‚úÖ First render ‚Üí check all
    if (!jobTypeFilterInitialized) {
      checkbox.checked = true;
      selectedJobTypes.add(type);
    } else {
      checkbox.checked = selectedJobTypes.has(type);
    }

    checkbox.onchange = () => {
      if (checkbox.checked) {
        selectedJobTypes.add(type);
      } else {
        selectedJobTypes.delete(type);
      }
      loadTasks();
    };

    label.appendChild(checkbox);
    label.append(` ${type} (${jobTypeCounts[type]})`);

    container.appendChild(label);
  });

  jobTypeFilterInitialized = true;
}

function syncDynamicFields(taskKey) {
  const box = document.getElementById(`dyn_${taskKey}`);
  if (!box) return;

  if (!BILLING_CACHE[taskKey]) return;

  const inputs = box.querySelectorAll("input, textarea");

  const allowedKeys = new Set();

  // Only allow CURRENT visible inputs
  inputs.forEach(el => {
    const k = el.getAttribute("data-key");
    if (k) allowedKeys.add(k);
  });

  // Purge stale keys
  for (const k of Object.keys(BILLING_CACHE[taskKey])) {
    if (k !== "deliveryType" && k !== "deliverytype_2nd" && !allowedKeys.has(k)) {
      delete BILLING_CACHE[taskKey][k];
    }
  }

  // Sync only current fields
  inputs.forEach(el => {
    const fieldKey = el.getAttribute("data-key");
    if (!fieldKey) return;

    BILLING_CACHE[taskKey][fieldKey] = el.value.trim();
  });
  // ‚úÖ PERSIST FORM STATE
  const all = loadFormCache();
  all[taskKey] = BILLING_CACHE[taskKey];
  saveFormCache(all);
}

function loadFormCache() {
  return JSON.parse(localStorage.getItem(FORM_CACHE_KEY) || "{}");
}

function saveFormCache(cache) {
  localStorage.setItem(FORM_CACHE_KEY, JSON.stringify(cache));
}

function startGPSTracking(driverId) {
  detectGPSPermission();
  if (!navigator.geolocation) return;

  const gpsStatus = document.getElementById("gpsStatus");

  if (gpsWatchId !== null) {
    navigator.geolocation.clearWatch(gpsWatchId);
    gpsWatchId = null;
  }

  gpsWatchId = navigator.geolocation.watchPosition(
    pos => {
      LAST_KNOWN_GPS = {
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude,
        accuracy: pos.coords.accuracy,
        timestamp: Date.now()
      };

      // ‚úÖ UPDATE UI HERE
      if (gpsStatus) {
        gpsStatus.innerText =
          `üì° GPS locked (¬±${Math.round(pos.coords.accuracy)}m)`;
      }

      update(ref(db, `driverStatus/${driverId}`), {
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude,
        accuracy: pos.coords.accuracy || null,
        lastSeen: new Date().toISOString()
      });
    },
    handleGPSError,
    {
      enableHighAccuracy: true,
      maximumAge: 5000,
      timeout: 20000
    }
  );
}

/* ===== NETWORK ===== */
function updateNetwork() {
  offlineBanner.style.display = navigator.onLine ? "none" : "block";
}
window.addEventListener("online", updateNetwork);
window.addEventListener("offline", updateNetwork);
updateNetwork();

/* ===== QUEUE ===== */
const getQueue = () => JSON.parse(localStorage.getItem(QUEUE_KEY) || "[]");
const setQueue = q => localStorage.setItem(QUEUE_KEY, JSON.stringify(q));

/* ===== IMAGE ===== */
function compressImage(file) {
  return new Promise(resolve => {
    const img = new Image();
    const r = new FileReader();
    r.onload = e => img.src = e.target.result;
    img.onload = () => {
      const c = document.createElement("canvas");
      let w = img.width, h = img.height;
      if (w > 1280) { h *= 1280 / w; w = 1280; }
      c.width = w; c.height = h;
      c.getContext("2d").drawImage(img, 0, 0, w, h);
      c.toBlob(b => resolve(b), "image/jpeg", 0.55);
    };
    r.readAsDataURL(file);
  });
}

const toBase64 = b => new Promise(r => {
  const f = new FileReader();
  f.onloadend = () => r(f.result);
  f.readAsDataURL(b);
});

  let CURRENT_TASK = null;
let CURRENT_PHOTO_INDEX = null;

window.startPhoto = function(index, taskKey) {
  if (!validateDynamic(taskKey)) return;

  CURRENT_TASK = taskKey;
  CURRENT_PHOTO_INDEX = index;

  cameraInput.value = "";
  cameraInput.click();
};

cameraInput.onchange = async e => {
  try {
  const file = e.target.files?.[0];
  if (!file || !CURRENT_TASK || !CURRENT_PHOTO_INDEX) return;

  if (!PHOTO_BUFFER[CURRENT_TASK]) PHOTO_BUFFER[CURRENT_TASK] = {};

  let blob;
  try {
    blob = await compressImage(file);
  } catch {
    alert("Image processing failed");
    return;
  }

  const gps = LAST_KNOWN_GPS;
  if (!gps || !gps.latitude) {
    alert("üìç Waiting for GPS signal...");
    return;
  }

  const previewURL = URL.createObjectURL(blob);
  
  PHOTO_BUFFER[CURRENT_TASK][CURRENT_PHOTO_INDEX] = {
    blob,
    previewURL,
    takenAt: new Date().toISOString(),
    gps,
    deliveryData: BILLING_CACHE[CURRENT_TASK] || {}
  };

  await savePhotoToDB({
  id: `${CURRENT_TASK}_${CURRENT_PHOTO_INDEX}`,
  taskKey: CURRENT_TASK,
  photoIndex: CURRENT_PHOTO_INDEX,
  blob,
  takenAt: new Date().toISOString(),
  gps,
  deliveryData: BILLING_CACHE[CURRENT_TASK] || {},
  submitIntent: false
});
  
  checkStorageQuota();

  // üîí Lock UI to this task after first photo
  if (CURRENT_PHOTO_INDEX === 1) {
    ACTIVE_CAPTURE_TASK = CURRENT_TASK;
  }

  CURRENT_PHOTO_INDEX = null;
  CURRENT_TASK = null;   // üî• REQUIRED FIX
  
  // ‚úÖ reset AFTER capture finishes
  setTimeout(() => {
    cameraInput.value = "";
  }, 150);
  
  // ‚úÖ Delay UI refresh to prevent Android camera crash
  setTimeout(() => {
    safeLoadTasks("photo captured");
  }, 300);
  } catch (err) {
      console.error("üì∏ Camera handler crash:", err);
      alert("Camera error ‚Äî please retry.");
    }
  };
  
  window.submitTask = async function(taskKey) {

  if (submitLock[taskKey]) return;
  submitLock[taskKey] = true;

  const btn = document.querySelector(
    `button[onclick="submitTask('${taskKey}')"]`
  );

  if (btn) {
    btn.disabled = true;
    btn.innerText = "‚è≥ Uploading...";
  }

  const photos = PHOTO_BUFFER[taskKey];

  if (!photos || Object.keys(photos).length === 0) {
    alert("Please take at least 1 photo.");
    submitLock[taskKey] = false;
    return;
  }

  // ==============================
  // ‚úÖ ALWAYS QUEUE (ONLINE OR OFFLINE)
  // ==============================
  
  let cachedTasks =
    JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]");
  
  // üîí Remove old copy
  cachedTasks = cachedTasks.filter(t => t._key !== taskKey);
  
  cachedTasks.push({
    _key: taskKey,
    status: "OFFLINE_PENDING",
    finalized: false
  });
  
  processingMap[taskKey] = true;
  
  localStorage.setItem(
    TASK_CACHE_KEY,
    JSON.stringify(cachedTasks)
  );
  
  // üîÅ STORE QUEUE ENTRY
  let q = getQueue().filter(x => x.taskKey !== taskKey);
  q.push({ taskKey });
  setQueue(q);

  // üîì MARK ALL INDEXEDDB PHOTOS FOR THIS TASK AS SUBMITTED
    const dbi = await openDB();
    
    await new Promise((resolve, reject) => {
      const tx = dbi.transaction(STORE, "readwrite");
      const store = tx.objectStore(STORE);
    
      const req = store.getAll();
    
      req.onsuccess = () => {
        req.result
          .filter(p => p.taskKey === taskKey)
          .forEach(p => {
            store.put({
              ...p,
              submitIntent: true
            });
          });
      };
    
      tx.oncomplete = resolve;
      tx.onerror = reject;
    });
  
  // üß† Photos already saved to IndexedDB at capture time
  delete PHOTO_BUFFER[taskKey];
  delete processingMap[taskKey];
  ACTIVE_CAPTURE_TASK = null;
  
  //loadTasks();
  
  submitLock[taskKey] = false;
  if (btn) {
    btn.disabled = false;
    btn.innerText = "‚úÖ Submit Task";
  }
  
  // üöÄ Let background uploader handle it
  setTimeout(processOfflineQueue, 1500);
  
  return;

  // ==============================
  // ‚úÖ ONLINE MODE (CURRENT FLOW)
  // ==============================

  processingMap[taskKey] = true;
  loadTasks();

  try {
    const indices = Object.keys(photos).map(Number).sort((a,b)=>a-b);
  
    for (const i of indices) {
      const p = photos[i];
  
      await uploadNow(
        taskKey,
        p.blob,
        p.takenAt,
        null,
        p.deliveryData,
        p.gps,
        i,
        i === indices[indices.length - 1]   // ‚úÖ last upload flag
      );
    }

    // üß† FREE ALL PREVIEW MEMORY AFTER SUBMIT
    if (PHOTO_BUFFER[taskKey]) {
      Object.values(PHOTO_BUFFER[taskKey]).forEach(p => {
        if (p.previewURL) URL.revokeObjectURL(p.previewURL);
      });
    }
    
    delete PHOTO_BUFFER[taskKey];
    delete processingMap[taskKey];
    ACTIVE_CAPTURE_TASK = null;
    
    loadTasks();

  } catch (e) {
    console.error(e);
    alert("‚ùå Upload failed.");
  }

  delete submitLock[taskKey];
};


/* ===== CAMERA ===== */

function saveToGallery(blob, filename) {
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = filename;

  document.body.appendChild(a);
  a.click();

  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

window.CURRENT_TASK = null;

function safeLoadTasks(reason = "") {
  // ‚ùå Do not refresh while user is answering a task
  if (ACTIVE_CAPTURE_TASK) {
    console.log("‚õî loadTasks blocked (active capture)", reason);
    return;
  }

  // ‚ùå Do not refresh while background upload is running
  if (OFFLINE_REPLAY_RUNNING) {
    console.log("‚õî loadTasks blocked (upload running)", reason);
    return;
  }

  loadTasks();
}

  
function updateRefreshLock() {
  if (isBusy()) {
    disablePullToRefresh();
  } else {
    enablePullToRefresh();
  }
}
  
  
function resolveStatus(task) {
  if (task.status === "COMPLETED") return "COMPLETED";

  const p = PHOTO_BUFFER[task._key];

  if (p) {
    const count = Object.keys(p).length;

    if (count > 0) return "READY";   // üî• ANY photo makes task ready
  }

  if (processingMap[task._key]) return "PROCESSING";
  if (uploadingMap[task._key]) return "UPLOADING";
  if (task.status === "OFFLINE_PENDING") return "SYNC_PENDING";

  return task.status || "PENDING";
}

async function uploadNow(
    taskKey,
    blob,
    takenAt,
    _ignoredFilename,
    deliveryData = {},
    photoGPS,
    photoIndex,
    isLastPhoto
  ) {
  const taskSnap = await get(ref(db, `tasks/${taskKey}`));
  const task = taskSnap.val() || {};

  if (!photoGPS || !photoGPS.latitude) {
    throw new Error("GPS_REQUIRED_AT_PHOTO_TIME");
  }

  // ===== BUILD FILENAME =====
  const safe = v => String(v || "")
    .toUpperCase()
    .replace(/[^A-Z0-9]+/g, "_")
    .replace(/^_|_$/g, "");

  const filename =
  `${safe(task.CUSTOMERNAME)}_${safe(task.ADDRESS)}_` +
  `P${photoIndex}_` +
  `${photoGPS.longitude}_${photoGPS.latitude}_` +
  `${task.driverId}_${new Date().toISOString()
    .replace(/[-:T.Z]/g, "")
    .slice(0,14)}.jpg`;

  // ‚úÖ SAVE FINAL IMAGE TO LOCAL GALLERY
  saveToGallery(blob, filename);

  // üîÅ MARK LAST UPLOAD ATTEMPT (VERY IMPORTANT)
  await update(ref(db, `tasks/${taskKey}`), {
    lastUploadAttemptAt: new Date().toISOString()
  });

  // ===== UPLOAD =====
  const imgRef = sRef(storage, `tasks/${taskKey}/${filename}`);
  await uploadBytes(imgRef, blob);
  const url = await getDownloadURL(imgRef);

  // ===== FLATTEN DATA =====
  const updatePayload = {
  ...(isLastPhoto ? { status: "COMPLETED", forceReopen: false } : {}),
    [`photo${photoIndex}Url`]: url,
    [`photo${photoIndex}Filename`]: filename,
    [`photo${photoIndex}TakenAt`]: takenAt,
    uploadedAt: new Date().toISOString(),
    deliveryType: deliveryData.deliveryType || ""
  };

  for (const [k, v] of Object.entries(deliveryData)) {
  if (k === "deliveryType") continue;

  if (k === "deliverytype_2nd") {
    updatePayload[k] = v;
    continue;
  }

  // append _2nd for radio child inputs
  const finalKey = deliveryData.deliverytype_2nd ? `${k}_2nd` : k;

  updatePayload[finalKey] = v;
}

  if (photoGPS && photoGPS.latitude) {
    updatePayload.LATITUDE  = photoGPS.latitude;
    updatePayload.LONGITUDE = photoGPS.longitude;
    updatePayload.gpsAccuracy = photoGPS.accuracy || null;
  }

  await update(ref(db, `tasks/${taskKey}`), updatePayload);


/* ================= FIX #3 START ================= */

// ‚úÖ FORCE CLEAN LOCAL CACHE AFTER ONLINE UPLOAD
const cachedTasks =
  JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]");

const idx = cachedTasks.findIndex(t => t._key === taskKey);
if (idx !== -1) {
  cachedTasks[idx].status = "COMPLETED";
  cachedTasks[idx].finalized = true;
}

localStorage.setItem(
  TASK_CACHE_KEY,
  JSON.stringify(cachedTasks)
);

/* ================= FIX #3 END ================= */
  // ‚úÖ CLEAR FORM CACHE AFTER SUCCESS
  const forms = loadFormCache();
  delete forms[taskKey];
  saveFormCache(forms);
  
  updateRefreshLock();
}

async function preloadDriverUIConfig(tasks) {
  for (const t of tasks) {
    if (t.JOBTYPE) {
      await loadDriverUI(t.JOBTYPE);
    }
  }
}
checkStorageQuota();
setInterval(checkStorageQuota, 60_000); // every 60 seconds
/* ===== LOAD TASKS ===== */
async function loadTasks() {
  try {
    let tasks = [];

    try {
      tasks = dedupeTasks(
        JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]")
      );
    } catch (e) {
      console.warn("‚ö†Ô∏è Corrupt cache ‚Äî resetting", e);
      localStorage.removeItem(TASK_CACHE_KEY);
      tasks = [];
    }

    localStorage.setItem(TASK_CACHE_KEY, JSON.stringify(tasks));
        
    if (navigator.onLine) {
      const snap = await get(
        query(ref(db, "tasks"), orderByChild("driverId"), equalTo(DRIVER_ID))
      );
    
      const raw = snap.val() || {};
      const serverTasks = Object.entries(raw)
        .filter(([k, v]) => v && typeof v === "object")
        .map(([k, v]) => ({ _key: k, ...v }));
    
      // üîí MERGE with local cache to preserve finalized/offline flags
      const localTasks =
        JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]");
    
      const merged = serverTasks.map(st => {
        const local = localTasks.find(lt => lt._key === st._key);
      
        // ‚úÖ SERVER COMPLETED ALWAYS FINAL
        if (st.status === "COMPLETED") {
          return { ...st, finalized: true };
        }
      
        // ‚úÖ If local offline processing exists ‚Üí LOCAL WINS
        if (local && (
            local.status === "OFFLINE_PENDING" ||
            processingMap[local._key] ||
            uploadingMap[local._key] || 
            PHOTO_BUFFER[local._key]
        )) {
          return { ...local, ...st, status: local.status };
        }
      
        if (!local) return st;
      
        return {
          ...local,
          ...st,
          finalized: false
        };
      });
    
      tasks = merged;

      tasks = tasks.map(t => {
        if (
          t.status === "PENDING" &&
          !t.forceReopen &&   // üëà THIS IS THE KEY
          (t.photo1Url || t.photo2Url || t.photo3Url) &&
          t.uploadedAt
        ) {
          if (navigator.onLine) {
            update(ref(db, `tasks/${t._key}`), {
              status: "COMPLETED"
            }).catch(() => {});
          }
      
          return { ...t, status: "COMPLETED", finalized: true };
        }
        return t;
      });
      
      localStorage.setItem(TASK_CACHE_KEY, JSON.stringify(tasks));
    }

    await preloadDriverUIConfig(tasks);

    tasks.sort((a, b) => {
      const priority = {
        PENDING: 1,
        PROCESSING: 3,
        UPLOADING: 4,
        COMPLETED: 5
      };
    
      const sa = priority[resolveStatus(a)] || 99;
      const sb = priority[resolveStatus(b)] || 99;
    
      // 1Ô∏è‚É£ STATUS ORDER (pending first, uploading last)
      if (sa !== sb) return sa - sb;
    
      // 2Ô∏è‚É£ SAME STATUS ‚Üí SAME UPLOAD BATCH
      if (a.uploadBatch !== b.uploadBatch) {
        return (a.uploadBatch || 0) - (b.uploadBatch || 0);
      }
    
      // 3Ô∏è‚É£ PRESERVE EXCEL ROW ORDER
      return (a.rowIndex || 0) - (b.rowIndex || 0);
    });
    
    updateRemainingCounter(tasks);
    updateUploadCounter(tasks);
    renderJobTypeFilters(tasks);
    const selectedDate = dateFilter.value; // YYYY-MM-DD
// üîí HIDE OTHER TASKS WHILE CAPTURING
if (ACTIVE_CAPTURE_TASK) {
  tasks = tasks.filter(t => t._key === ACTIVE_CAPTURE_TASK);
}
const filtered = tasks
  .filter(t => {
    const status = resolveStatus(t);

    // ‚ùå Never show completed
    if (status === "COMPLETED") return false;

    // ‚ùå Must match selected date
    const taskDate = normalizeDatePH(t.createdAt);
      if (!taskDate || taskDate !== selectedDate) {
        return false;
      }

    // ‚ùå Job type filter
    if (
      selectedJobTypes.size > 0 &&
      !selectedJobTypes.has(t.JOBTYPE)
    ) {
      return false;
    }

    return true;
  })
  .filter(t => {
    if (!SEARCH_TERM) return true;

    const haystack = Object.values(t)
      .filter(v => typeof v === "string" || typeof v === "number")
      .join(" ")
      .toLowerCase();

    return haystack.includes(SEARCH_TERM);
  });
    
    render(filtered);

    if (!gpsWatchId) {
      setTimeout(() => startGPSTracking(DRIVER_ID), 1000);
    }
  } catch (e) {
    taskList.innerHTML = "‚ö†Ô∏è Failed to load tasks. Pull to refresh.";
  }
}

async function detectGPSPermission() {
  if (!navigator.permissions) return;

  try {
    const result = await navigator.permissions.query({ name: "geolocation" });

    if (result.state === "denied") {
      gpsStatus.innerText =
        "üö´ Location blocked ‚Äî Tap ‚öôÔ∏è ‚Üí Allow Location";
    }

    result.onchange = () => detectGPSPermission();
  } catch {}
}

function handleGPSError(err) {
  const gpsStatus = document.getElementById("gpsStatus");

  let msg = "";

  switch (err.code) {
    case 1:
      msg = "üö´ Location blocked ‚Äî Phone Settings ‚Üí App ‚Üí Allow Location (Always)";
      break;

    case 2:
      msg = "üì¥ GPS is OFF ‚Äî Turn ON Location services";
      break;

    case 3:
      msg = "‚è≥ Can't get GPS ‚Äî Move to open area & wait";
      break;

    default:
      msg = "‚ö†Ô∏è GPS error ‚Äî Restart phone";
  }

  if (gpsStatus) gpsStatus.innerText = msg;
}

function updateUploadCounter(tasks) {
  if (!Array.isArray(tasks)) return;

  const uploadingCount = tasks.filter(t => {
    const status = resolveStatus(t);
    return (
      status === "SYNC_PENDING" ||
      status === "PROCESSING" ||
      status === "UPLOADING"
    );
  }).length;

  const el = document.getElementById("uploadCounter");
  const retryBtn = document.getElementById("retryUploadBtn");

  if (!el) return;

  if (uploadingCount > 0) {
    el.innerText = `‚è´ Pending Uploads: ${uploadingCount}`;
    el.style.display = "block";

    if (retryBtn) retryBtn.style.display = "block";
  } else {
    el.innerText = "";
    el.style.display = "none";

    if (retryBtn) retryBtn.style.display = "none";
  }
}
  
function updateRemainingCounter(tasks) {
  const selectedDate =
    document.getElementById("dateFilter")?.value;

  if (!selectedDate) return;

  const remaining = tasks.filter(t => {
    const status = resolveStatus(t);

    // ‚úÖ pending only
    if (status !== "PENDING") return false;

    // ‚úÖ must match selected date
    const taskDate = normalizeDatePH(t.createdAt);
      if (!taskDate || taskDate !== selectedDate) {
        return false;
      }

    return true;
  }).length;

  const el = document.getElementById("taskCounter");
  if (el) {
    el.innerText = `üìÑ Remaining Tasks: ${remaining}`;
  }
}  
/* ===== RENDER ===== */
async function render(tasks) {
  taskList.innerHTML = "";

  for (const t of tasks) {
    const p = PHOTO_BUFFER[t._key] || {};
    // ‚úÖ RESTORE FORM STATE IF EXISTS
    const savedForms = loadFormCache();
    if (savedForms[t._key] && !BILLING_CACHE[t._key]) {
      BILLING_CACHE[t._key] = savedForms[t._key];
    }
    if (!BILLING_CACHE[t._key]) {
      BILLING_CACHE[t._key] = {};
    }
    
    const status = resolveStatus(t);

    const div = document.createElement("div");
    div.className = `task ${status === "COMPLETED" ? "completed" : ""}`;

    const hasGPS =
  t.LATITUDE &&
  t.LONGITUDE &&
  !isNaN(parseFloat(t.LATITUDE)) &&
  !isNaN(parseFloat(t.LONGITUDE));


const mapURL = hasGPS
  ? `https://www.google.com/maps?q=${t.LATITUDE},${t.LONGITUDE}`
  : null;

const addressHTML = hasGPS
  ? `<a href="${mapURL}" target="_blank"
        style="color:#007bff;text-decoration:underline;font-weight:bold;">
        üìç ${t.ADDRESS || "‚Äî"}
     </a>`
  : `<div>üìç ${t.ADDRESS || "‚Äî"}</div>`;

    let html = `
      <b>${t.CUSTOMERNAME || "‚Äî"}</b>
    
      <div class="small">${addressHTML}</div>
    
      <div class="small"><b>Account #:</b> ${t.ACCOUNTNUMBER || "‚Äî"}</div>
      <div class="small"><b>MRU:</b> ${t.MRU || "‚Äî"}</div>
      <div class="small"><b>Meter #:</b> ${t.METERNUMBER || "‚Äî"}</div>
      <div class="small"><b>DMZ:</b> ${t.DMZ || "‚Äî"}</div>
      <div class="small"><b>Sequence:</b> ${t.SEQUENCE || "‚Äî"}</div>
      <div class="small"><b>Job Type:</b> ${t.JOBTYPE || "‚Äî"}</div>
      <div class="small"><b>Status:</b> ${status}</div>
    `;
    if (t.lastUploadAttemptAt) {
      html += `
        <div class="small" style="color:#888">
          ‚è± Last upload attempt:
          ${new Date(t.lastUploadAttemptAt).toLocaleTimeString()}
        </div>
      `;
    }

    /* ===== PENDING (EDITABLE ONLINE + OFFLINE) ===== */
    if ((status === "PENDING" || status === "CAPTURING" || status === "READY") && !t.finalized) {
      const p = PHOTO_BUFFER[t._key] || {};
      const count = Object.keys(p).length;
    
      if (count > 0) {
        html += `
          <div class="uploading" style="color:green;">
            üì∏ Photos taken: ${count} ‚Äî you may submit
          </div>
        `;
      }
    
      // üîí Hide delivery options after Photo 1 is taken
      if (ACTIVE_CAPTURE_TASK !== t._key) {
        html += await renderDynamicDelivery(t);
      }
    
      /* ===== PREVIEW THUMBNAILS (MOVE ABOVE BUTTONS) ===== */
      const previews = [1,2,3].map(i => {
        if (!p[i]?.previewURL) return "";
        return `
          <img src="${p[i].previewURL}"
            onclick="window.open('${p[i].previewURL}','_blank')"
            style="
              width:100%;
              max-width:100px;
              height:80px;
              object-fit:cover;
              border-radius:6px;
              border:2px solid #28a745;
              cursor:pointer;
            "
          />
        `;
      }).join("");
    
      if (previews) {
        html += `
          <div style="
            display:grid;
            grid-template-columns:repeat(3,1fr);
            gap:6px;
            margin-top:8px;
          ">
            ${previews}
          </div>
        `;
      }
    
      /* ===== PHOTO BUTTONS ===== */

      const disable1 = !!p[1];
      const disable2 = !p[1] || !!p[2];
      const disable3 = !p[2] || !!p[3];
      const disableSubmit = Object.keys(p).length === 0;
      
      html += `
        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-top:8px;">
          <button
            ${disable1 ? "disabled" : ""}
            onclick="startPhoto(1,'${t._key}')"
            style="
              background:${p[1] ? '#28a745' : '#007bff'};
              color:white;
              opacity:${disable1 ? 0.5 : 1};
            ">
            üì∏ Photo 1
          </button>
      
          <button
            ${disable2 ? "disabled" : ""}
            onclick="startPhoto(2,'${t._key}')"
            style="
              background:${p[2] ? '#28a745' : '#007bff'};
              color:white;
              opacity:${disable2 ? 0.5 : 1};
            ">
            üì∏ Photo 2
          </button>
      
          <button
            ${disable3 ? "disabled" : ""}
            onclick="startPhoto(3,'${t._key}')"
            style="
              background:${p[3] ? '#28a745' : '#007bff'};
              color:white;
              opacity:${disable3 ? 0.5 : 1};
            ">
            üì∏ Photo 3
          </button>
        </div>
      
        <button
          ${disableSubmit ? "disabled" : ""}
          onclick="submitTask('${t._key}')"
          style="
            background:#2c3e50;
            color:white;
            opacity:${disableSubmit ? 0.5 : 1};
          ">
          ‚úÖ Submit Task
        </button>
      `;
    }
    
    
    /* ===== PROCESSING ===== */
    if (status === "SYNC_PENDING") {
      html += `
        <div class="uploading">
          üì¶ Saved safely ‚Äî will auto-upload when signal is stable,keep app open while uploading
        </div>
      `;
    }

    /* ===== UPLOADING ===== */
    if (status === "UPLOADING") {
      html += `<div class="uploading">‚è≥ Uploading photo‚Ä¶</div>`;
    }

    /* ===== COMPLETED ===== */
    if (status === "COMPLETED") {
      html += `
        <button class="toggle"
          onclick="
            const img = this.parentElement.querySelector('img');
            if (!img) return;
            img.style.display = img.style.display === 'none'
              ? 'block'
              : 'none';
          ">
          üëÅ Show / Hide Photo
        </button>

        <img src="${t.imageUrl}" style="display:none">
      `;
    }

    div.innerHTML = html;
    taskList.appendChild(div);
  }
}

function canUploadNow() {
  if (!navigator.onLine) return false;

  if (navigator.connection) {
    const c = navigator.connection;
    
    if (c.effectiveType === "2g" || c.effectiveType === "slow-2g") {
      return false;
    }
  }
  return true;
}

function renderCachedOnly() {
  const tasks =
    JSON.parse(localStorage.getItem(TASK_CACHE_KEY) || "[]");

  if (ACTIVE_CAPTURE_TASK) {
    tasks = tasks.filter(t => t._key === ACTIVE_CAPTURE_TASK);
  }
  
  const selectedDate = dateFilter.value;

  const filtered = tasks.filter(t => {
    const status = resolveStatus(t);
    if (status === "COMPLETED") return false;

    const taskDate = normalizeDatePH(t.createdAt);
    if (!taskDate || taskDate !== selectedDate) return false;

    if (
      selectedJobTypes.size > 0 &&
      !selectedJobTypes.has(t.JOBTYPE)
    ) return false;

    return true;
  });

  render(filtered);
}
  
async function renderDynamicDelivery(t) {
  const methods = await loadDriverUI(t.JOBTYPE);
  if (!methods || typeof methods !== "object") return "";

  const methodNames = Object.keys(methods);
  if (!methodNames.length) return "";

  let html = `<div class="radio-group"><b>Delivery Method</b>`;

  for (const m of methodNames) {
    html += `
      <label>
        <input type="radio" name="delivery_${t._key}" value="${m}"
          onchange="handleDeliveryMethod('${t._key}','${t.JOBTYPE}','${m}')">
        ${m}
      </label>`;
  }

  html += `</div><div id="dyn_${t._key}"></div>`;
  // üîÅ Restore selected delivery method UI
  const saved = BILLING_CACHE[t._key];
  if (saved?.deliveryType) {
    const radio = document.querySelector(
      `input[name="delivery_${t._key}"][value="${saved.deliveryType}"]`
    );
    if (radio) radio.checked = true;
  }
  // üîÅ Auto-rebuild child fields if previously selected
if (saved?.deliveryType && saved?.deliverytype_2nd) {
  setTimeout(() => {
    handleDeliveryMethod(
      t._key,
      t.JOBTYPE,
      saved.deliveryType
    );

    setTimeout(() => {
      handleRadioTrigger(
        t._key,
        t.JOBTYPE,
        saved.deliveryType,
        saved.deliverytype_2nd
      );
    }, 0);
  }, 0);
}
  return html;
}

  
function getCurrentLocation() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject("Geolocation not supported");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      pos => {
        resolve({
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude
        });
      },
      err => reject(err.message),
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      }
    );
  });
}

function dedupeTasks(tasks) {
  const map = new Map();

  const rank = {
    PENDING: 1,
    OFFLINE_PENDING: 2,
    PROCESSING: 3,
    UPLOADING: 4,
    COMPLETED: 5
  };

  for (const t of tasks) {
    if (!t || !t._key) continue;

    const prev = map.get(t._key);
    if (!prev) {
      map.set(t._key, t);
    } else {
      const r1 = rank[prev.status] || 0;
      const r2 = rank[t.status] || 0;

      if (r2 >= r1) map.set(t._key, t);
    }
  }

  return [...map.values()];
}
  
function validateDynamic(taskKey) {
  syncDynamicFields(taskKey);

  const data = BILLING_CACHE[taskKey];

  // 1Ô∏è‚É£ Delivery method required
  if (!data?.deliveryType) {
    alert("Select delivery method");
    return false;
  }

  // 2Ô∏è‚É£ Task must exist
  const task = JSON.parse(localStorage.getItem("cachedTasks") || "[]")
    .find(t => t._key === taskKey);

  if (!task) {
    alert("Task not found. Please refresh.");
    return false;
  }

  // 3Ô∏è‚É£ Config MUST exist (offline-safe)
  const jobCfg = DRIVER_UI_CACHE[task.JOBTYPE];
  if (!jobCfg) {
    alert("Delivery configuration not available. Please go online once.");
    return false;
  }

  const methodCfg = jobCfg[data.deliveryType];
  if (!methodCfg) {
    alert("Invalid delivery method. Please reselect.");
    return false;
  }

  // =============================
  // ‚úÖ DIRECT FIELD VALIDATION
  // =============================
  for (const key of methodCfg._order || []) {
    const field = methodCfg.fields[key];
    if (field.type === "radio") continue;
  
    if (field.required && !data[key]) {
      alert(`${field.label} is required`);
      return false;
    }
  }

  // =============================
  // ‚úÖ RADIO CHILD FIELD VALIDATION
  // =============================
  
  const selectedRadio = data.deliverytype_2nd;

  if (selectedRadio) {
    const radioField = methodCfg.fields[selectedRadio];
  
    const childOrder = radioField?.fields?._order || [];
  
    for (const k of childOrder) {
      const f = radioField.fields.options[k];
  
      if (f.required && !data[k]) {
        alert(`${f.label} is required`);
        return false;
      }
    }
  }
  return true;
}  
loadTasks();

let OFFLINE_REPLAY_RUNNING = false;

// üîÅ Resume offline uploads AFTER UI is ready
setTimeout(processOfflineQueue, 1500);



// üîÅ Resume uploads when app returns to foreground
document.addEventListener("visibilitychange", () => {
  if (!document.hidden) {
    processOfflineQueue();
  }
});

// üîÅ Resume uploads when app gains focus
window.addEventListener("focus", () => {
  processOfflineQueue();
});

// üîÅ Safety retry while app is open
setInterval(() => {
  if (!OFFLINE_REPLAY_RUNNING && canUploadNow()) {
    processOfflineQueue();
  }
}, 15000);
  
async function processOfflineQueue() {
  const dbg = await getAllPhotosFromDB();
    console.log("üì¶ IndexedDB photos", dbg.map(p => ({
      id: p.id,
      taskKey: p.taskKey,
      submitIntent: p.submitIntent
    })));
  if (OFFLINE_REPLAY_RUNNING) return;
      OFFLINE_REPLAY_RUNNING = true;
    
      try {
        if (!navigator.onLine || !canUploadNow()) {
      console.log("‚è∏ Upload paused ‚Äî will retry");
      OFFLINE_REPLAY_RUNNING = false;
    
      // üîÅ auto-retry later even if no network event fires
      setTimeout(processOfflineQueue, 5000);
      return;
    }

    const records = (await getAllPhotosFromDB())
      .filter(r => r.submitIntent !== false);
    if (!records.length) {
      OFFLINE_REPLAY_RUNNING = false;
      return;
    }

    // ‚úÖ GROUP BY TASK
    const grouped = {};
    for (const r of records) {
      if (!grouped[r.taskKey]) grouped[r.taskKey] = [];
      grouped[r.taskKey].push(r);
    }

    for (const taskKey of Object.keys(grouped)) {
      if (!canUploadNow()) break;

      await update(ref(db, `tasks/${taskKey}`), {
        lastUploadAttemptAt: new Date().toISOString()
      });
      
      const photos = grouped[taskKey]
        .sort((a, b) => a.photoIndex - b.photoIndex);

      uploadingMap[taskKey] = true;
      safeLoadTasks("upload start");

      for (let i = 0; i < photos.length; i++) {
        const p = photos[i];
        const isLast = i === photos.length - 1;

        try {
          await new Promise(r => setTimeout(r, 120));
          
          await uploadNow(
            p.taskKey,
            p.blob,
            p.takenAt,
            null,
            p.deliveryData || {},
            p.gps,
            p.photoIndex,
            isLast
          );

          await deletePhotoFromDB(p.id);

        } catch (e) {
            console.error("‚ùå Upload failed", p.taskKey, p.photoIndex, e);
          
            // ‚úÖ CLEAN UP STATE SO UI DOES NOT GET STUCK
            delete uploadingMap[p.taskKey];
            delete processingMap[p.taskKey];
            safeLoadTasks("upload error cleanup");
          
            continue; // ‚õî stop this task, retry later
          }
      }

      delete uploadingMap[taskKey];
      delete processingMap[taskKey];
      safeLoadTasks("upload finished");
    }
    checkStorageQuota();

    const remaining = await getAllPhotosFromDB();
    if (!remaining.length) {
      setQueue([]);
    }

  } finally {
    OFFLINE_REPLAY_RUNNING = false;
  }
}

window.manualRetryUploads = async function () {
  if (OFFLINE_REPLAY_RUNNING) {
    alert("‚è≥ Upload already in progress");
    return;
  }

  if (!navigator.onLine) {
    alert("üì¥ You are offline. Connect to the internet first.");
    return;
  }

  alert("üîÅ Retrying pending uploads‚Ä¶\n\nPlease keep the app open.");

  await processOfflineQueue();
  safeLoadTasks("manual retry finished"); // ‚úÖ
};

window.addEventListener("online", async () => {
  await processOfflineQueue();
  safeLoadTasks("back online");
});

let startY = 0;

window.addEventListener(
  "touchstart",
  e => {
    if (e.touches.length === 1) {
      startY = e.touches[0].clientY;
    }
  },
  { passive: true }
);

window.handleDeliveryMethod = async function(taskKey, jobType, method) {
  if (!BILLING_CACHE[taskKey]) BILLING_CACHE[taskKey] = {};
    BILLING_CACHE[taskKey].deliveryType = method;

  const cfg = await loadDriverUI(jobType);
  const block = cfg?.[method];
  const box = document.getElementById(`dyn_${taskKey}`);

  if (!box || !block) return;
  box.innerHTML = "";

  let html = "";

  for (const key of block._order || []) {
    const field = block.fields[key];
    if (!field) continue;

    const req = field.required ? " *" : "";

    // TEXT / TEXTAREA
    if (field.type === "text" || field.type === "textarea") {
      if (field.type === "textarea") {
        html += `
          <div class="delivery-fields">
            <label>${field.label}${req}</label>
            <textarea data-key="${key}"
              oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value"></textarea>
          </div>`;
      } else {
        html += `
          <div class="delivery-fields">
            <label>${field.label}${req}</label>
            <input type="text" data-key="${key}"
              oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value"/>
          </div>`;
      }
    }

    // RADIO TRIGGER
    if (field.type === "radio") {
      html += `
        <div class="radio-group">
          <label>
            <input type="radio"
              name="radio_${taskKey}"
              value="${key}"
              onchange="handleRadioTrigger('${taskKey}','${jobType}','${method}','${key}')">
            ${field.label}
          </label>
        </div>
      `;
    }
  }

  html += `<div id="sub_${taskKey}"></div>`;
  box.innerHTML = html;
  saveFormCache({
  ...loadFormCache(),
  [taskKey]: BILLING_CACHE[taskKey]
});
};

window.handleRadioTrigger = async function(taskKey, jobType, method, radioKey) {
  BILLING_CACHE[taskKey].deliverytype_2nd = radioKey;
  const cfg = await loadDriverUI(jobType);
  const radioBlock = cfg?.[method]?.fields?.[radioKey];
  const box = document.getElementById(`sub_${taskKey}`);

  if (!box) return;

  // üî• CLEAR OLD CHILD UI
  box.innerHTML = "";

  // üî• REMOVE OLD CHILD DATA
  syncDynamicFields(taskKey);

  // ‚ùå No children ‚Üí STOP
  if (!radioBlock?.fields?._order?.length) return;

  let html = `<div class="delivery-fields">`;

  for (const key of radioBlock.fields._order) {
    const field = radioBlock.fields.options[key];
    const req = field.required ? " *" : "";

    if (field.type === "textarea") {
      html += `
        <label>${field.label}${req}</label>
        <textarea data-key="${key}"
          oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value"></textarea>`;
    } else {
      html += `
        <label>${field.label}${req}</label>
        <input type="text" data-key="${key}"
          oninput="BILLING_CACHE['${taskKey}']['${key}'] = this.value">`;
    }
  }

  html += `</div>`;
  box.innerHTML = html;
};
  
window.addEventListener(
  "touchmove",
  e => {
    const y = e.touches[0].clientY;
    const pullingDown = y > startY;

    if (pullingDown && window.scrollY === 0 && isBusy()) {
      e.preventDefault();
    }
  },
  { passive: false }
);
  
</script>

<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js");
}
</script>

<script>
let deferredPrompt = null;

function isStandalone() {
  return window.matchMedia("(display-mode: standalone)").matches ||
         window.navigator.standalone === true;
}



window.addEventListener("beforeinstallprompt", e => {
  // already installed ‚Üí do nothing
  if (isStandalone()) return;

  e.preventDefault();
  deferredPrompt = e;

  // prevent duplicates
  if (document.getElementById("installBtn")) return;

  const btn = document.createElement("button");
  btn.id = "installBtn";
  btn.innerText = "üì≤ Install Driver App";
  btn.style = `
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 420px;
    padding: 14px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 10px;
    border: none;
    background: #007bff;
    color: #fff;
    z-index: 99999;
  `;

  btn.onclick = async () => {
    btn.disabled = true;
    await deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    btn.remove();
    deferredPrompt = null;
  };

  document.body.appendChild(btn);
});
</script>

<script>
window.addEventListener("appinstalled", () => {
  const btn = document.getElementById("installBtn");
  if (btn) btn.remove();
});
</script>

</body>
</html>
